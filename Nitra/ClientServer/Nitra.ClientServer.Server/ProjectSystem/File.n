using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.ClientServer.Messages;
using Nitra.ClientServer.Server.ServerUtils;
using Nitra.Declarations;
using Nitra.Internal;
using Nitra.PrettyPrint;

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;

using NSP  = Nitra.ProjectSystem;
using SC   = System.Collections;
using Span = Nitra.ClientServer.Messages.NSpan;

namespace Nitra.ClientServer.Server.ProjectSystem
{
  internal class File : NSP.File, IDisposable
  {
    // TODO: override ParseResult, Ast, GetParseTree and so on and implement parsing/typing in work threads
    public  Parent                  : Project;
    public  override Id             : int                     { get { this.FileId.Value } }
    public  FileId                  : FileId                  { get; }
    public  CancellationTokenSource : CancellationTokenSource { get; private set; }
    public  DynamicExtensions       : Seq[GrammarDescriptor]  { get; }
    public  IsDisposed              : bool                    { get; private set; }
    public  IsActive                : bool                    { get; private set; }
    public  override Version        : int                     { get { this.FileVersion.Value } }
    public  FileVersion             : FileVersion             { get; private set; }
            _parseQueue             : BlockingCollection[ParserMessage];
    mutable _fileInfo               : FileInfo;
    mutable _text                   : StringBuilder;
    mutable _snapshot               : SourceSnapshot;
    mutable _name                   : string;
    mutable _parseResult            : IParseResult;
    mutable _ast                    : IAst;
    mutable _parseTree              : ParseTree;
    mutable _objToIdMap             : ConcurrentDictionary[object, int];
    mutable _idToObjMap             : ConcurrentDictionary[int, object];
    mutable _needHint               : bool;
    mutable _caretPosOpt            : int = -1;
    mutable _caretPosVersionOpt     : int = -1;
    
    public this(id : FileId, fullPath : string, version : FileVersion, parent : Project)
    {
      base(null);
      FileId            = id;
      _fileInfo         = FileInfo(fullPath);
      Parent            = parent;
      _name             = IO.Path.GetFileNameWithoutExtension(FullName);
      _parseQueue       = parent.ParseQueue;
      FileVersion       = version;
      (Language, DynamicExtensions) = parent.GetLanguage(Path.GetExtension(fullPath));
      // TODO: Add statistics support.
      
      parent.AddFile(this);
    }

    /// Used for in memory text editing (with no file available)
    public this(id : FileId, name : string, parent : Project, text : string)
    {
      base();
      FileId    = id;
      Parent    = parent;
      _snapshot = SourceSnapshot(text, this, 0);
      _text     = StringBuilder(text);
      _name     = name;
      (Language, DynamicExtensions) = parent.GetLanguage(Path.GetExtension(name));
      
      parent.AddFile(this);
    }
    
    public override Ast : IAst { get { _ast } }
    public override Language : Language { get; }
    public override Name : string { get { _name } }
    public override FullName : string { get { _fileInfo.FullName } }
    
    public IsSupported : bool { get { this.Language != null } }
    
    public override GetSource() : SourceSnapshot
    { 
      when (_snapshot == null)
      {
        assert2(_fileInfo != null);
        assert(_fileInfo != null);
        def text  = File.ReadAllText(_fileInfo.FullName, Encoding.UTF8); // TODO: add detect BOM and load UTF-8 if no BOM avalable
        _snapshot = SourceSnapshot(text, this, Version);
        _text     = StringBuilder(text);
      }
      
      _snapshot
    }
    
    public override Length : int
    {
      get
      {
        if (_text == null)
        {
          assert2(_fileInfo != null);
          assert(_fileInfo != null);
          _fileInfo.Length :> int
        }
        else
          _text.Length
      }
    }
    
    public override Project : NSP.Project { get { Parent } }
    
    public Dispose() : void
    {
      assert2(!IsDisposed);

      when (IsDisposed)
        return;

      def cts = CancellationTokenSource;
      when (cts != null)
      {
        CancellationTokenSource = null;
      
        unless (cts.IsCancellationRequested)
          cts.Cancel();
        cts.Dispose();
      }
      
      IsDisposed = true;
    }
 
    Insert(pos: int, text: string) : void
    {
      _ = _text.Insert(pos, text)
    }
    
    Delete(span: Span) : void
    {
      _ = _text.Remove(span.StartPos, span.Length)
    }
    
    Replace(span: Span, text: string) : void
    {
      Delete(span);
      Insert(span.StartPos, text)
    }
    
    ApplyChange(change : FileChange) : void
    {
      | FileChange.Insert(pos, text)   => Insert(pos, text)
      | FileChange.Delete(span)        => Delete(span)
      | FileChange.Replace(span, text) => Replace(span, text)
    }
    
    public Change(version : FileVersion, change : FileChange) : void
    {
      _ = GetSource();
      FileVersion = version;
      ApplyChange(change);
      _snapshot = SourceSnapshot(_text.ToString(), this, version);

      TrySendParseMessage();
    }
    
    public Change(version : FileVersion, changes : ImmutableArray[FileChange]) : void
    {
      _ = GetSource();
      FileVersion = version;
      for (mutable i = changes.Length - 1; i >= 0; i--)
        ApplyChange(changes[i]);
      _snapshot = SourceSnapshot(_text.ToString(), this, version);
      //IO.File.WriteAllText($@"C:\Temp\005\$Name$(version.Value).ncs", _snapshot.Text);
      
      TrySendParseMessage();
    }
    
    // overrides
    
    GetReParseMessage() : ParserMessage.ParseFile
    {
      _parseMessages.Clear();
      _astMessages.Clear();
      _typingMessages.Clear();
      
      def language = Language;
      assert2(language.StartRule != null);
 
      CancellationTokenSource?.Cancel();
      CancellationTokenSource?.Dispose();
      
      if (_ast == null)
        Parent.CancelSemanticAnalysisCancellation();
      else
      {
        _parseResult = null;
        _ast         = null;
        _parseTree   = null;
        Parent.AstDropped(this);
      }
        
      def cancellationTokenSource = CancellationTokenSource();
      def cancellationToken       = cancellationTokenSource.Token;
      def source                  = GetSource();
      def parseSession            = ParseSession(language.StartRule, 
                                        language.CompositeGrammar,
                                        cancellationToken = cancellationToken,
                                        dynamicExtensions = DynamicExtensions);
      CancellationTokenSource = cancellationTokenSource;

      ParserMessage.ParseFile(Parent.Parent.Id, this.FileId, parseSession, source)
    }
    
    public CreateAstMessage(parseResult : IParseResult) : ParserMessage.CreateAst
    {
      _parseResult = parseResult;
      TryMatchBrackets();
      
      _parseTree   = parseResult.CreateParseTree(); 
      ParserMessage.CreateAst(Parent.Parent.Id, this.FileId, parseResult, IsActive)
    }
    
    public AstCreated(ast : IAst, parseTree : ParseTree) : void
    {
      _parseTree = parseTree; 
      _ast = ast;
      
      TryHighlightSymbolReferences();
      
      // TODO: make _astMessages local for working threads
      //_astMessages = NSP.CompilerMessageList();
      Parent.AstCreated(this);
    }
    
    public CreateVisualInfo(parseResult : IParseResult) : void
    {
      def solutionId = Parent.Parent.Id;
      _parseQueue.Add(ParserMessage.CreateKeywordsHighlighting(solutionId, this.FileId, parseResult));
      _parseQueue.Add(ParserMessage.CreateOutlining(solutionId, this.FileId, parseResult));
    }
    
    public Activate() : void
    {
      IsActive = true;
      
      when (!this.IsSupported)
        return;
      
      def parseResult = _parseResult;
      
      when (parseResult != null)
      {
        CreateVisualInfo(parseResult);
        SendCompilerMessages(parseResult);
        SendSemanticAnalysisMessages();
      }
        
      TryPrettyPrint();
      TryCreateParseTreeReflection();
        
      when (Parent.IsSemanticAvailable)
        Parent.ParseQueue.Add(ParserMessage.CreateSymbolsHighlighting(Parent.Parent.Id, this.FileId, this.FileVersion, Ast));
    }
    
    SendSemanticAnalysisMessages() : void
    {
      def cm = Parent.GetSemanticAnalysisMessages(FileId);
      Parent.Router.SendAsyncResponse(AsyncServerMessage.SemanticAnalysisMessages(FileId(FileId), FileVersion(FileVersion), Parent.Parent.Id, cm));
    }
    
    SendCompilerMessages(parseResult : IParseResult) : void
    {
      def parent = Parent;
      ServerUtils.SendCompilerMessages(parseResult, parent.Router, parent.Parent.Id, this.FileId);
    }
    
    TryCreateParseTreeReflection() : void
    {
      def router           = Parent.Router;
      when (router.IsParseTreeReflectionEnable && _parseResult != null)
        Parent.ParseQueue.Add(ParserMessage.CreateParseTreeReflection(Parent.Parent.Id, this.FileId, this.FileVersion, _parseResult));
    }
    
    TryPrettyPrint() : void
    {
      def router           = Parent.Router;
      def prettyPrintState = router.PrettyPrintState;
      when (router.PrettyPrintState != PrettyPrintState.Disabled && _parseTree != null)
        Parent.ParseQueue.Add(ParserMessage.CreatePrettyPrint(Parent.Parent.Id, this.FileId, this.FileVersion, prettyPrintState, _parseTree));
    }    
    public Deactivate() : void
    {
      IsActive = false;
    }
    
    public CompleteWord(version : int, pos : int) : void
    {
      when (_parseResult == null || _ast == null || version != _parseResult.SourceSnapshot.Version)
      {
        Log("CompleteWord $Id skipped");
        return;
      }

      def timer = Stopwatch.StartNew();
      def router = Parent.Router;
      mutable replacementSpan;
      def result = NitraUtils.CompleteWord(pos, _parseResult, _ast, out replacementSpan);
      def builder = ImmutableArray.CreateBuilder();
      foreach (elem in result)
      {
        | text is string => builder.Add(CompletionElem.Literal(text));
        | s is DeclarationSymbol when s.IsNameValid =>
          def name = s.Name;
          when (string.IsNullOrEmpty(name) && !char.IsLetter(name[0]))
            continue;

          def content = s.ToXaml();
          builder.Add(CompletionElem.Symbol(s.Id, name, content, content, 0)); // TODO: add support of iconId & description
          
        | _ => assert2(false);
      }
      router.SendResponse(ServerMessage.CompleteWord(Parent.Parent.Id, ServerUtils.ConvertNSpan(replacementSpan), builder.ToImmutable()));
      LogMsgHandled("CompleteWord " + Id + " finished.", timer, 200);
    }
    
    public FindSymbolDefinitions(fileVersion : int, pos : int) : void
    {
      def ast = _ast;
      
      when (ast == null || ast.Location.Source.Version != fileVersion)
      {
        // maybe better return special message?
        assert2(false);
        Parent.Router.SendResponse(ServerMessage.FindSymbolDefinitions(Parent.Parent.Id, NSpan(), ImmutableArray.Empty));
        return;
      }
        
      def action(cancellationToken : CancellationToken, solutionId : SolutionId, _asts : ImmutableArray[IAst]) : void
      { // execute when Parent.IsSemanticAvailable 
        def router             = this.Parent.Router;
        def pos                = pos;
        def ast                = ast;
        def (refSpan, symbols) = GetSymbols(cancellationToken, pos, ast);
        
        def biulder = ImmutableArray.CreateBuilder();
        foreach (symbol in symbols)
          foreach (decl in symbol.GetDeclarationsUntyped())
            biulder.Add(SymbolLocation(symbol.Id, ServerUtils.ConvertLocation(decl.Name.Location, withText=true)));
      
        def names = biulder.ToImmutableArray();
        router.SendResponse(ServerMessage.FindSymbolDefinitions(solutionId, refSpan, names));
      }
      
      Parent.AddSemanticAction(action);
    }
    
    public FindSymbolReferences(fileVersion : int, pos : int, forHighlighting : bool) : void
    {
      def ast      = _ast;
      def needHint = _needHint && forHighlighting;
      _needHint    = false;
      
      when (ast == null || ast.Location.Source.Version != fileVersion)
      {
        // maybe better return special message?
        assert2(false);
        Parent.Router.SendResponse(ServerMessage.FindSymbolReferences(Parent.Parent.Id, NSpan(), ImmutableArray.Empty));
        return;
      }
        
      def action(cancellationToken : CancellationToken, solutionId : SolutionId, mutable asts : ImmutableArray[IAst]) : void
      { // execute when Parent.IsSemanticAvailable 
        def router             = this.Parent.Router;
        def pos                = pos;
        def ast                = ast;

        def (refSpan, symbols) = GetSymbols(cancellationToken, pos, ast);
        def defsBiulder        = ImmutableArray.CreateBuilder();
        def symbolsBiulder     = ImmutableArray.CreateBuilder(symbols.Length);
        def refsBiulder        = ImmutableArray.CreateBuilder();
        def spansBiulder       = ImmutableArray.CreateBuilder();
        
        when (forHighlighting)
          asts = ImmutableArray.Create(ast);
          
        def hintBuilderOpt = if (needHint) Text.StringBuilder("<hint>", 64) else null;

        foreach (symbol in symbols)
        {
          when (needHint)
            _ = hintBuilderOpt.AppendLine(symbol.MakeHint()); // TODO: add GetHint()
          
          def decls = symbol.GetDeclarationsUntyped();
          assert2(defsBiulder.Count == 0);
          defsBiulder.Capacity = decls.Count();
          
          foreach (decl in decls)
            defsBiulder.Add(SymbolLocation(symbol.Id, ServerUtils.ConvertLocation(decl.Name.Location, !forHighlighting)));
            
          def projectSupport = Parent.GetProjectSupport();
          def visitor = CollectSymbolRefsAstVisitor(cancellationToken, projectSupport, symbol);
          
          for (mutable i = 0; i < asts.Length; i++)
          {
            def curAst = asts[i];
            when (curAst == null)
              continue;
            visitor.FoundSymbols.Clear();
            curAst.Accept(visitor);
            def source       = curAst.Source;
            def fileIdentity = FileIdentity(FileId(source.File.Id), FileVersion(source.Version));
            
            
            assert2(spansBiulder.Count == 0);
            spansBiulder.Capacity = visitor.FoundSymbols.Count;

            foreach (r in visitor.FoundSymbols)
              spansBiulder.Add(ServerUtils.ConvertToRange(r.Location, !forHighlighting));

            refsBiulder.Add(FileEntries(fileIdentity, spansBiulder.MoveToImmutable()));
          }

          symbolsBiulder.Add(SymbolRreferences(symbol.Id, defsBiulder.MoveToImmutable(), refsBiulder.ToImmutable()));
        }
        
        when (needHint)
        {
          def source = ast.Location.Source;
          def hint   = hintBuilderOpt.Append("</hint>").ToString();
          router.SendAsyncResponse(AsyncServerMessage.Hint(FileId(source.File.Id), FileVersion(source.Version), solutionId, hint, refSpan));
        }        

        if (forHighlighting)
        {
          def source = ast.Location.Source;
          router.SendAsyncResponse(AsyncServerMessage.FindSymbolReferences(FileId(source.File.Id), FileVersion(source.Version), solutionId, refSpan, symbolsBiulder.MoveToImmutable()));
        }
        else
          router.SendResponse(ServerMessage.FindSymbolReferences(solutionId, refSpan, symbolsBiulder.MoveToImmutable()));
      }
      
      Parent.AddSemanticAction(action);
    }
  
    static GetSymbols(cancellationToken : CancellationToken, pos : int, ast : IAst) : Span * array[DeclarationSymbol]
    {
      def visitor = CollectSymbolsAndRefsInSpanAstVisitor(cancellationToken, NSpan(pos));
      ast.Accept(visitor);
      
      def symbols = HashSet();
      mutable refSpan : Span;
      
      unless (cancellationToken.IsCancellationRequested)
        foreach (name when name.IsSymbolEvaluated in visitor.Names)
        {
          when (refSpan == default(Span))
            refSpan = ServerUtils.ConvertNSpan(name.Span);

          _ = symbols.Add(name.Symbol);
        }
        
      unless (cancellationToken.IsCancellationRequested)
        foreach (r when r.IsSymbolEvaluated in visitor.Refs)
        {
          when (refSpan == default(Span))
            refSpan = ServerUtils.ConvertNSpan(r.Location.Span);

          _ = symbols.Add(r.Symbol);
        }
        
      (refSpan, symbols.ToArray())
    }
    
    public static GetText(obj : IAst) : string
    {
      try
      {
        def maxLen = 200;
        def loc    = obj.Location;
        def span   = loc.Span;
        def text   = loc?.Source?.OriginalText;
      
        when (text == null)
          return <#«incorrect Source for AST»#>;
      
        def index  = text.IndexOfAny(array['\r', '\n'], span.StartPos, span.Length);
        def len    = if (index > 0) index - span.StartPos else Math.Min(maxLen, span.Length);
        if (len == span.Length)
          text.Substring(span.StartPos, len)
        else
          text.Substring(span.StartPos, len) + "..."
      }
      catch { e => LogException(e); $<#«Exception: $(e.Message)»#>; }
    }

    public static GetText(obj : object) : string
    {
      def str    = obj.ToString();
      def index  = str.IndexOfAny(array['\r', '\n']);
      def maxLen = 200;
      def len    = if (index > 0 && index < maxLen) index else maxLen;
      if (str.Length > len)
        str.Substring(0, len) + "..."
      else
        str
    }
    
    public GetObjectContent(solutionId : SolutionId, fileVersion : int, objectId : int) : void
    {
      def ast = _ast;
      
      when (ast == null || ast.Location.Source.Version != fileVersion || Parent.Data == null || Parent.Parent.Id != solutionId)
      {
        Parent.Router.SendResponse(ServerMessage.ObjectContent(solutionId, ContentDescriptor.Fail("AST not created yet.")));
        return;
      }
      
      def action(cancellationToken : CancellationToken, solutionId : SolutionId, _asts : ImmutableArray[IAst]) : void
      {
        try
        {
          def objectId   = objectId;
          when (objectId == 0)
          lock (this)
          {
            if (_objToIdMap == null)
            {
              _objToIdMap  = ConcurrentDictionary();
              _idToObjMap  = ConcurrentDictionary();
            }
            else
            {
              _objToIdMap.Clear();
              _idToObjMap.Clear();
            }
          
            _objToIdMap[ast] = 0;
            _idToObjMap[0]   = ast;
          }

          def objToIdMap = _objToIdMap;
          def idToObjMap = _idToObjMap;
        
          assert2(objToIdMap != null);
          assert2(idToObjMap != null);
        
          when (cancellationToken.IsCancellationRequested)
          {
            Parent.Router.SendResponse(ServerMessage.ObjectContent(solutionId, ContentDescriptor.Fail("Operation canceled.")));
            return;
          }
        
          def astType = typeof(IAst);
          def isContentProperty(prop : PropertyInfo) : bool
          {
            def name = prop.Name;
            match (name)
            {
              | "HasValue" => true
              | "Id" | "IsMissing" | "File" | "Span" | "IsAmbiguous" => false
              | _ => !(name.StartsWith("Is", StringComparison.Ordinal) && name.EndsWith("Evaluated", StringComparison.Ordinal))
                && !name.Equals("IsAllPropertiesEvaluated", StringComparison.Ordinal) && prop.GetIndexParameters().Length == 0
            }
          }
          def findObject() : object
          {
            def ast = ast;
            mutable obj;
            obj = if (objectId == 0) ast
                  else if (idToObjMap.TryGetValue(objectId, out obj)) obj
                  else null;
                  
            when (ast?.Location.Source.Version != fileVersion)
              obj = null;

            obj
          }
          def obj = findObject();
          def readMembers(obj : object) : array[PropertyDescriptor]
          {
            def t = obj.GetType();
            def members = t.GetProperties(BindingFlags.Instance | BindingFlags.Public)
                           .Where(isContentProperty)
                           .Select(readValue(obj, t, _))
                           .Concat(
                            t.GetFields(BindingFlags.Instance | BindingFlags.Public)
                             .Select(readFieldValue(obj, t, _)))
                           .OrderBy(x => x.Name)
                           .ToArray();
            members
          }
          and loadObjectContent(obj : object) : ContentDescriptor
          {
            match (obj)
            {
              | obj is IAstList[IAst] => ContentDescriptor.AstItems(readMembers(obj), obj.MapToArray(toObjectDescriptor))
              | obj is IAst           => ContentDescriptor.Members(readMembers(obj))
              | obj is SC.IEnumerable => ContentDescriptor.Items(obj.Cast.[object]().MapToArray(toObjectDescriptor))
              | _ => ContentDescriptor.Members(readMembers(obj))
            }
          }
          and toObjectDescriptor(obj : object) : ObjectDescriptor
          {
            def count(seq : SC.IEnumerable) : int
            {
              | x is SC.ICollection => x.Count
              | _ => 
                mutable i;
                foreach (_ in seq)
                  i++;
                i
            }
            def getId(obj : object) : int
            {
              assert2(obj != null);
            
              mutable id;
              unless (objToIdMap.TryGetValue(obj, out id))
              {
                id = objToIdMap.Count;
                objToIdMap[obj] = id;
                idToObjMap[id]  = obj;
              }
          
              id
            }
          
            match (obj)
            {
              | null                    => ObjectDescriptor.Null()
              | obj is DeclarationSymbol => def t = obj.GetType();  ObjectDescriptor.Symbol(getId(obj), obj.Name, obj.FullName, t.Name, t.FullName, null)
              | obj is IAstList[IAst]   => ObjectDescriptor.AstList(ConvertNSpan(obj.Span), getId(obj), null, null, obj.Count)
              | obj is IAst           => def t = obj.GetType(); ObjectDescriptor.Ast(ConvertNSpan(obj.Span), getId(obj), GetText(obj), t.Name, t.FullName, null)
              | obj is string         =>
                mutable i = 0;
                for (mutable nlCount = 0; nlCount < 5 && i < obj.Length && i < 400; )
                {
                  def index = obj.IndexOf('\n', i);
                  if (index >= 0)
                  {
                    i = index + 1;
                    nlCount++;
                  }
                  else
                    i++;
                }
              
                ObjectDescriptor.String(if (obj.Length == i) obj else (obj.Substring(0, i) + "..."))
              
              | obj is SC.IEnumerable => ObjectDescriptor.Seq(getId(obj), null, count(obj))
              | obj is System.Int16   => ObjectDescriptor.Int16  (obj)
              | obj is System.Int32   => ObjectDescriptor.Int32  (obj)
              | obj is System.Int64   => ObjectDescriptor.Int64  (obj)
              | obj is System.Char    => ObjectDescriptor.Char   (obj)
              | obj is System.SByte   => ObjectDescriptor.SByte  (obj)
              | obj is System.UInt16  => ObjectDescriptor.UInt16 (obj)
              | obj is System.UInt32  => ObjectDescriptor.UInt32 (obj)
              | obj is System.UInt64  => ObjectDescriptor.UInt64 (obj)
              | obj is System.Byte    => ObjectDescriptor.Byte   (obj)
              | obj is System.Single  => ObjectDescriptor.Single (obj)
              | obj is System.Double  => ObjectDescriptor.Double (obj)
              | obj is System.Boolean => ObjectDescriptor.Boolean(obj)
              | obj is IParsedValue   => ObjectDescriptor.Parsed(ConvertNSpan(obj.Span), toObjectDescriptor(obj.Value))
              | _                     => def t = obj.GetType(); ObjectDescriptor.Object(getId(obj), GetText(obj), t.Name, t.FullName, null)
            }
          }
          and readFieldValue(obj : object, t : System.Type, field : FieldInfo) : PropertyDescriptor
          {
            def name      = field.Name;
            def objDesc   = toObjectDescriptor(field.GetValue(obj));

            PropertyDescriptor(PropertyKind.Simple, name, objDesc)
          }
          and readValue(obj : object, t : System.Type, prop : PropertyInfo) : PropertyDescriptor
          {
            def name           = prop.Name;
            def propType       = prop.PropertyType;
            def attr           = prop.GetCustomAttributes(typeof(PropertyAttribute), false).FirstOrDefault() :> PropertyAttribute;
            //def isDependent    = attr?.IsDependent;
            def isOut          = attr?.IsOut;
            def isIn           = attr?.IsIn;
            def isEvalPropName = "Is" + name + "Evaluated";
            def isEvalProp     = t.GetProperty(isEvalPropName);
            def kind =
              match (isIn, isOut)
              {
                | (true,  false) => PropertyKind.DependentIn
                | (true,   true) => PropertyKind.DependentInOut
                | (false,  true) => PropertyKind.DependentOut
                | (false, false) when astType.IsAssignableFrom(propType) => PropertyKind.Ast
                | (false, false) => PropertyKind.Simple
              };
            def objDesc =
              if (isEvalProp == null || isEvalProp.GetValue(obj, null) :> bool)
                toObjectDescriptor(prop.GetValue(obj, null))
              else
                ObjectDescriptor.NotEvaluated();

            PropertyDescriptor(kind, name, objDesc)
          }
        
          def content = loadObjectContent(obj);
          Parent.Router.SendResponse(ServerMessage.ObjectContent(solutionId, content));
        }
        catch
        {
          | e => Parent.Router.SendResponse(ServerMessage.ObjectContent(solutionId, ContentDescriptor.Fail(e.ToString())));
        }
      }
      
      Parent.AddSemanticAction(action);
    }

    public RenameFile(newId : FileId, newPath : string): void
    {
      def newVersion = FileVersion(); // TODO: get from client
      def project = Parent;
      project.RemoveFile(this);
      def newFile = File(newId, newPath, newVersion, project);
      newFile.TrySendParseMessage();
    }
    
    public TrySendParseMessage() : void
    {
      when (this.IsSupported)
        _parseQueue.Add(this.GetReParseMessage());
    }
    
    public SetCaretPos(fileVersion : int, pos : int) : void
    {
      _caretPosOpt        = pos;
      _caretPosVersionOpt = fileVersion;
      
      TryMatchBrackets();
      TryHighlightSymbolReferences();
    }
    
    public GetHint(fileVersion : int, pos : int) : void
    {
      _needHint           = true;
      _caretPosOpt        = pos;
      _caretPosVersionOpt = fileVersion;
      
      TryHighlightSymbolReferences();
    }
    
    TryMatchBrackets() : void
    {
      when (_caretPosOpt < 0)
        return;
 
      when (_caretPosVersionOpt < 0)
        return;
      
      def parseResult = _parseResult;
      
      when (parseResult != null && parseResult.SourceSnapshot.Version == _caretPosVersionOpt)
      {
        def solutionId  = Parent.Parent.Id;
        _parseQueue.Add(ParserMessage.CreateMatchBrackets(solutionId, this.FileId, parseResult, _caretPosOpt));
      }
    }
    
    TryHighlightSymbolReferences() : void
    {
      when (_caretPosOpt < 0)
        return;
 
      when (_caretPosVersionOpt < 0)
        return;
        
      def ast = _ast;
      
      when (ast == null || ast.Location.Source.Version != _caretPosVersionOpt)
        return;

      FindSymbolReferences(_caretPosVersionOpt, _caretPosOpt, forHighlighting=true);
    }
    
    public override ToString() : string { $"$Name($(Parent.Name) project)" }
  
    public override HasAst                : bool               { get { _ast != null } }
    public override ParseResult           : Nitra.IParseResult { get { _parseResult }   }
    public override GetParseTree()        : Nitra.ParseTree    { _parseTree }
    
    public override DeepResetProperties() : void               { throw System.NotImplementedException() }
  }
}