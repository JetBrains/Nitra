using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using Nitra.ClientServer.Messages;

using System;
using System.Console;
using System.Globalization;
using System.Threading;
using System.Collections.Generic;
using System.IO;
using System.IO.Pipes;
using System.Linq;

namespace Nitra.ClientServer.Client
{
  public class ServerPipe : IDisposable
  {
    mutable _pipeServer: NamedPipeServerStream;
    public PipeName: string { get; private set }
    
    public this(onMessage: ServerMessage -> void, priority: ThreadPriority = ThreadPriority.Normal)
    {
      PipeName = Guid.NewGuid().ToString();
      _pipeServer = NamedPipeServerStream(PipeName, PipeDirection.InOut);
      
      def reader()
      {
        def thread = Thread.CurrentThread;
        thread.Name = "ServerPipeReader " + PipeName;
        thread.CurrentCulture = CultureInfo.InvariantCulture;
        _pipeServer.WaitForConnection();
        
        using (reader = BinaryReader(_pipeServer))
        {
          def loop()
          {
            try
            {
              onMessage(Deserializer.Deserialize(reader));
              loop()
            }
            catch
            {
              | _ is EndOfStreamException when !_pipeServer.IsConnected =>
                Log("Session has been terminated.")
              | e => 
                Log($"Message read error: $e");
                loop()
            }
          }
          
          loop()
        }
      }
       
      def readerThread = Thread(reader) <-
      {
        IsBackground = true;
        Priority = priority
      };
      readerThread.Start();
      Log($"Pipe server started (pipe name = $PipeName).");
    }
    
    public Dispose() : void 
    {
      _pipeServer?.Dispose();
      _pipeServer = null
    }
    
    Log(msg : string) : void
    {
      WriteLine(msg);
    }
  }
}
