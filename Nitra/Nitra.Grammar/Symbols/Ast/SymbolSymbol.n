using Nitra.Model;
using Nitra.ProjectSystem;
using Nitra.Serialization;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;

using G = NitraSyntaxParseTree;
using SCG = System.Collections.Generic;

namespace Nitra.Typing
{
  [Record, ExportableSymbol]
  public abstract class SymbolSymbol : PropertyContainerSymbol, INamespaceMember
  {
    public override Description  : string             { get { "symbol" } }
    public abstract Declaration  : AstSymbol          { get; }
    public abstract IsSealed     : bool               { get; }
    public abstract IsExtensible : bool               { get; }
    public abstract BaseSymbols  : list[SymbolSymbol] { get; }

    public AllBaseSymbols : Seq[SymbolSymbol]
    {
      get { TypeInheritance(); _allBaseSymbols }
    }

    public override AllProperties : Seq[PropertySymbol]
    {
      get { TypeInheritance(); _allProperties.Values }
    }

    public IsSubtypeOf(other : SymbolSymbol) : bool
    {
      TypeInheritance();

      this == other || _allBaseSymbols.Contains(other)
    }

    [RecordIgnore] private mutable _allBaseSymbols : SCG.HashSet[SymbolSymbol];
    [RecordIgnore] private mutable _allProperties  : SCG.Dictionary[string, PropertySymbol];

    public TypeInheritance() : void
    {
      when (_allBaseSymbols : object == null)
      {
        _allBaseSymbols = SCG.HashSet();
        _allProperties  = SCG.Dictionary(StringComparer.Ordinal);

        foreach (s when _allBaseSymbols.Add(s) in BaseSymbols)
          _allBaseSymbols.UnionWith(s.AllBaseSymbols);

        CollectInheritedProperties(_allBaseSymbols, _allProperties);
        CollectDeclaredProperties(_allProperties);
      }
    }

    public override LookupProperty(name : string) : ValueOption[PropertySymbol]
    {
      assert(_allProperties : object != null);
      mutable p;
      if (_allProperties.TryGetValue(name, out p))
        VSome(p)
      else
        VNone()
    }
  }

  public sealed class ParsedAbstractSymbolSymbol : SymbolSymbol, IDependentPropertyAssignmentContainer
  {
    public this(astSymbol : AstSymbol, baseSymbols : list[SymbolSymbol])
    {
      base (astSymbol.FirstLocation, astSymbol.Name + "Symbol");
      Declaration = astSymbol;
      BaseSymbols = baseSymbols;
      _assignments = SCG.List();
      _initializedOutProperties = [];
    }

    private         _assignments              : SCG.List[DependentPropertyAssignment];
    private mutable _initializedOutProperties : list[DependentPropertySymbol];

    public override Declaration              : AstSymbol                     { get; }
    public override BaseSymbols              : list[SymbolSymbol]            { get; }
    public override IsSealed                 : bool                          { get { false } }
    public override IsExtensible             : bool                          { get { false } }
    public override InitializedOutProperties : list[DependentPropertySymbol] { get { _initializedOutProperties } }
    public override IsAbstract               : bool                          { get { true } }

    public AddAssignment(assignment : DependentPropertyAssignment) : void { AddAssignmentImpl(assignment, _assignments, ref _initializedOutProperties); }
    public GetAssignments() : Seq[DependentPropertyAssignment] { _assignments }
  }

  public sealed class ParsedSimpleSymbolSymbol : SymbolSymbol, IDependentPropertyAssignmentContainer
  {
    public this(astSymbol : AstSymbol, baseSymbols : list[SymbolSymbol])
    {
      base (astSymbol.FirstLocation, astSymbol.Name + "Symbol");
      Declaration = astSymbol;
      BaseSymbols = baseSymbols;
      _assignments = SCG.List();
      _initializedOutProperties = [];
    }

    private         _assignments              : SCG.List[DependentPropertyAssignment];
    private mutable _initializedOutProperties : list[DependentPropertySymbol];

    public override Declaration              : AstSymbol                     { get; }
    public override BaseSymbols              : list[SymbolSymbol]            { get; }
    public override IsSealed                 : bool                          { get { true } }
    public override IsExtensible             : bool                          { get { false } }
    public override InitializedOutProperties : list[DependentPropertySymbol] { get { _initializedOutProperties } }
    public override IsAbstract               : bool                          { get { false } }

    public AddAssignment(assignment : DependentPropertyAssignment) : void { AddAssignmentImpl(assignment, _assignments, ref _initializedOutProperties); }
    public GetAssignments() : Seq[DependentPropertyAssignment] { _assignments }
  }

  public sealed class ParsedExtensibleSymbolSymbol : SymbolSymbol, IDependentPropertyAssignmentContainer
  {
    public this(astSymbol : AstSymbol, baseSymbols : list[SymbolSymbol])
    {
      base (astSymbol.FirstLocation, astSymbol.Name + "Symbol");
      Declaration = astSymbol;
      BaseSymbols = baseSymbols;
      _assignments = SCG.List();
      _initializedOutProperties = [];
    }

    private         _assignments              : SCG.List[DependentPropertyAssignment];
    private mutable _initializedOutProperties : list[DependentPropertySymbol];

    public override Declaration              : AstSymbol                     { get; }
    public override BaseSymbols              : list[SymbolSymbol]            { get; }
    public override IsSealed                 : bool                          { get { false } }
    public override IsExtensible             : bool                          { get { true } }
    public override InitializedOutProperties : list[DependentPropertySymbol] { get { _initializedOutProperties } }
    public override IsAbstract               : bool                          { get { true } }

    public AddAssignment(assignment : DependentPropertyAssignment) : void { AddAssignmentImpl(assignment, _assignments, ref _initializedOutProperties); }
    public GetAssignments() : Seq[DependentPropertyAssignment] { _assignments }
  }

  public sealed class ParsedExtensionSymbolSymbol : SymbolSymbol, IDependentPropertyAssignmentContainer
  {
    public this(astSymbol : AstSymbol, baseSymbols : list[SymbolSymbol])
    {
      base (astSymbol.FirstLocation, astSymbol.Name + "Symbol");
      Declaration = astSymbol;
      BaseSymbols = baseSymbols;
      _assignments = SCG.List();
      _initializedOutProperties = [];
    }

    private         _assignments              : SCG.List[DependentPropertyAssignment];
    private mutable _initializedOutProperties : list[DependentPropertySymbol];

    public override Declaration              : AstSymbol                     { get; }
    public override BaseSymbols              : list[SymbolSymbol]            { get; }
    public override IsSealed                 : bool                          { get { true } }
    public override IsExtensible             : bool                          { get { false } }
    public override InitializedOutProperties : list[DependentPropertySymbol] { get { _initializedOutProperties } }
    public override IsAbstract               : bool                          { get { false } }

    public AddAssignment(assignment : DependentPropertyAssignment) : void { AddAssignmentImpl(assignment, _assignments, ref _initializedOutProperties); }
    public GetAssignments() : Seq[DependentPropertyAssignment] { _assignments }
  }
}
