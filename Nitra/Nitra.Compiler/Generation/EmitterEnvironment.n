using Nitra.Model;
using Nitra.Typing;
using Nitra.ProjectSystem;

using Nemerle;
using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Imperative;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Compiler
{
  public class EmitterEnvironment
  {
    public Manager                   : ManagerClass              { get; }
    public Project                   : NitraProject              { get; }
    public Root                      : HierarchyNode             { get { Project.RootNamespace.Node } }
    public DefaultTypeCompiler       : NTypeCompiler             { get; }
    public AstListTypeCompiler       : NTypeCompiler             { get; }
    public AstOptionTypeCompiler     : NTypeCompiler             { get; }

    public IsDebug                   : bool                      { get; }
    public EnableOptimization        : bool                      { get { !IsDebug } }
    public IsIdeMode                 : bool                      { get { Manager.IsIntelliSenseMode } }
    public OptionTypeInfo            : TypeInfo                  { get; }
    public ListTypeInfo              : TypeInfo                  { get; }
    public ParseTreeTypeInfo         : TypeInfo                  { get; }
    public ParseTreeTypeVar          : FixedType                 { get; }
    public AstTypeInfo               : TypeInfo                  { get; }
    public AstTypeVar                : FixedType                 { get; }
    public DeclarationTypeInfo       : TypeInfo                  { get; }
    public DeclarationTypeVar        : FixedType                 { get; }
    public ReferenceTypeInfo         : TypeInfo                  { get; }
    public ReferenceTypeVar          : FixedType                 { get; }
    public NameTypeInfo              : TypeInfo                  { get; }
    public NameTypeVar               : FixedType                 { get; }
    public ParsedValueTypeInfo       : TypeInfo                  { get; }
    public ListParseTreeTypeInfo     : TypeInfo                  { get; }
    public OptionParseTreeTypeInfo   : TypeInfo                  { get; }
    public SequenceParseTreeTypeInfo : Dictionary[int, TypeInfo] { get; }
    public NSpanTypeInfo             : TypeInfo                  { get; }
    public NSpanTypeVar              : FixedType                 { get; }
    public LocationTypeInfo          : TypeInfo                  { get; }
    public LocationTypeVar           : FixedType                 { get; }
    public FileTypeInfo              : TypeInfo                  { get; }
    public FileTypeVar               : FixedType                 { get; }
    public SymbolTypeInfo            : TypeInfo                  { get; }
    public SymbolTypeVar             : FixedType                 { get; }
    public IExportableSymbolTypeInfo : TypeInfo                  { get; }
    public IExportableSymbolTypeVar  : FixedType                 { get; }
    public Int32TypeInfo             : TypeInfo                  { get; }
    public Int32TypeVar              : FixedType                 { get; }
    public StringTypeInfo            : TypeInfo                  { get; }
    public StringTypeVar             : FixedType                 { get; }
    public BooleanTypeInfo           : TypeInfo                  { get; }
    public BooleanTypeVar            : FixedType                 { get; }

    public this(manager : ManagerClass, project : NitraProject)
    {
      Manager                   = manager;
      Project                   = project;
      IsDebug                   = manager.Options.IsConstantDefined("DEBUG") || manager.Options.IsConstantDefined("PARSER_DEBUG");
      OptionTypeInfo            = Manager.LookupTypeInfo("Nemerle.Core.option", 1);
      ListTypeInfo              = Manager.LookupTypeInfo("Nemerle.Core.list", 1);
      ParseTreeTypeInfo         = Manager.LookupTypeInfo("Nitra.ParseTree", 0);
      ParseTreeTypeVar          = FixedType.Class(ParseTreeTypeInfo, []);
      AstTypeInfo               = Manager.LookupTypeInfo("Nitra.Declarations.IAst", 0);
      AstTypeVar                = FixedType.Class(AstTypeInfo, []);
      DeclarationTypeInfo       = Manager.LookupTypeInfo("Nitra.Declarations.IDeclaration", 0);
      DeclarationTypeVar        = FixedType.Class(DeclarationTypeInfo, []);
      ReferenceTypeInfo         = Manager.LookupTypeInfo("Nitra.Declarations.IReference", 0);
      ReferenceTypeVar          = FixedType.Class(ReferenceTypeInfo, []);
      NameTypeInfo              = Manager.LookupTypeInfo("Nitra.Declarations.IName", 0);
      NameTypeVar               = FixedType.Class(NameTypeInfo, []);
      ParsedValueTypeInfo       = Manager.LookupTypeInfo("Nitra.ParsedValue");
      ListParseTreeTypeInfo     = Manager.LookupTypeInfo("Nitra.ListParseTree", 1);
      OptionParseTreeTypeInfo   = Manager.LookupTypeInfo("Nitra.OptionParseTree", 1);
      SequenceParseTreeTypeInfo = Dictionary();
      for (mutable i = 2; i <= 10; ++i)
        SequenceParseTreeTypeInfo[i] = Manager.LookupTypeInfo("Nitra.SequenceParseTree", i);
      NSpanTypeInfo             = Manager.LookupTypeInfo("Nitra.NSpan", 0);
      NSpanTypeVar              = FixedType.Class(NSpanTypeInfo, []);
      LocationTypeInfo          = Manager.LookupTypeInfo("Nitra.Location", 0);
      LocationTypeVar           = FixedType.Class(LocationTypeInfo, []);
      FileTypeInfo              = Manager.LookupTypeInfo("Nitra.ProjectSystem.File", 0);
      FileTypeVar               = FixedType.Class(FileTypeInfo, []);
      SymbolTypeInfo            = Manager.LookupTypeInfo("Nitra.Typing.Symbol", 0);
      SymbolTypeVar             = FixedType.Class(SymbolTypeInfo, []);
      IExportableSymbolTypeInfo = Manager.LookupTypeInfo("Nitra.Serialization.IExportableSymbol", 0);
      IExportableSymbolTypeVar  = FixedType.Class(IExportableSymbolTypeInfo, []);
      Int32TypeInfo             = Manager.LookupTypeInfo("System.Int32", 0);
      Int32TypeVar              = FixedType.Class(Int32TypeInfo, []);
      StringTypeInfo            = Manager.LookupTypeInfo("System.String", 0);
      StringTypeVar             = FixedType.Class(StringTypeInfo, []);
      BooleanTypeInfo           = Manager.LookupTypeInfo("System.Boolean", 0);
      BooleanTypeVar            = FixedType.Class(BooleanTypeInfo, []);
      DefaultTypeCompiler       = DefaultNTypeCompiler(this);
      AstListTypeCompiler       = AstListNTypeCompiler(DefaultTypeCompiler);
      AstOptionTypeCompiler     = AstOptionNTypeCompiler(DefaultTypeCompiler);
    }

    public NamespaceOfSymbol(symbol : Symbol) : GlobalEnv
    {
      Manager.CoreEnv.EnterIntoNamespace(symbol.Node.Parent.FullNameParts);
    }

    [Memoize]
    public GetParseTreeType(symbol : RuleSymbol) : FixedType
    {
      assert(symbol is SyntaxRuleSymbol(Type = RuleType.Ref));
      def nsParts       = symbol.DeclaringModule.Node.Parent.FullNameParts;
      def moduleName    = symbol.DeclaringModule.Name + "ParseTree";
      def parseTreeName = moduleName :: symbol.ParseTreeModuleRelativeName;
      BindFixedType(nsParts + parseTreeName)
    }

    [Memoize]
    public GetAstType(symbol : AstSymbol) : FixedType
    {
      BindFixedType(symbol.Node.FullNameParts)
    }

    public GetSymbolClassName(symbol : AstSymbol) : string
    {
      assert(symbol.IsDeclaration);

      symbol.Name + "Symbol"
    }

    [Memoize]
    public GetSymbolClass(symbol : AstSymbol) : FixedType
    {
      def nsParts =
        if (symbol is ExtensionAstSymbol)
          symbol.Node.Parent.Parent.FullNameParts
        else
          symbol.Node.Parent.FullNameParts;

      def className = GetSymbolClassName(symbol);
      BindFixedType(nsParts + [className])
    }

    public GetAstType(astType : AstType) : PExpr
    {
      | Ast        (symbol) => <[ $(GetAstType(symbol) : typed) ]>
      | Option     (symbol) => <[ $(GetAstType(symbol) : typed).IAstOption ]>
      | List       (symbol)
      | OptionList (symbol) => <[ $(GetAstType(symbol) : typed).IAstList ]>
      | Void                => <[ void ]>
    }

    public GetParseTreeType(ruleType : RuleType) : FixedType
    {
      match (ruleType)
      {
        | Void         => FixedType.Void()
        | Chars        => NSpanTypeVar
        | Ref(symbol)  => GetParseTreeType(symbol)
        | List(ty)     => FixedType.Class(ListParseTreeTypeInfo, [GetParseTreeType(ty)])
        | Option(ty)   => FixedType.Class(OptionParseTreeTypeInfo, [GetParseTreeType(ty)])
        | Tuple(types) =>
          def len = types.Length;
          mutable typeInfo;
          if (SequenceParseTreeTypeInfo.TryGetValue(len, out typeInfo))
            FixedType.Class(typeInfo, types.Map(GetParseTreeType(_)))
          else
            Message.FatalError($"Sequence of size '$len' is not supported");
      }
    }

    [Memoize]
    internal LookupAstPropertySymbol(prop : IProperty) : DependentAstPropertyRef
    {
      foreach (x in prop.GetModifiers().GetCustomAttributes())
      {
        | <[ Nitra.Internal.DependentPropertyAttribute($(fullName : string), $(index : int)) ]> =>
          def result = Root.BindMany.[DependentAstPropertySymbol](fullName.SplitToList('.'));
          return match (result)
          {
            | [one] => DependentAstPropertyRef.Reflected(one, index)
            | _     => null
          }

        | _ => ()
      }
      null
    }

    internal GetParseTreeType(ruleType : ChemicalRuleType) : FixedType
    {
      | Void         => FixedType.Void()
      | Root(symbol) => GetParseTreeType(symbol)
      | Tuple(types) => FixedType.Tuple(types.Map(GetParseTreeType(_)))
      | StaticString => StringTypeVar
      | String       => StringTypeVar
      | Bool         => BooleanTypeVar
      | Option(item) => FixedType.Class(OptionTypeInfo, [GetParseTreeType(item)])
      | Int          => Int32TypeVar
      | List(item)   => FixedType.Class(ListTypeInfo, [GetParseTreeType(item)])
    }

    public GetAmbiguousAstType(astSymbol : AstSymbol) : PExpr
    {
      <[ $(GetAstType(astSymbol) : typed).$(AstEmitter.AmbiguousOrMissingAstName : usesite) ]>
    }

    [Memoize]
    public MakeSubruleOffsetName(subrule : SubruleCompileInfo) : string
    {
      $"<# $(subrule)  offset $(subrule.Offset) #>"
    }

    [Memoize]
    public MakeSequenceHeaderOffsetName(sequenceHeader : SequenceHeaderCompileInfo) : string
    {
      def title = match (sequenceHeader)
      {
        | Id    => "Id"
        | Next  => "Next"
        | State => "State"
      };
      $"<# $(title)  offset $(sequenceHeader.Offset) #>"
    }

    public MakeSpanClassRef(spanClassSymbol : SpanClassSymbol) : PExpr
    {
      assert2(spanClassSymbol != null);
      def expr = PExprUtils.FromQualifiedIdentifier(spanClassSymbol.DeclaringModule.Node.FullNameParts);
      <[ $expr.$("SpanClass_" + spanClassSymbol.Name : usesite) ]>
    }

    private BindFixedType(typeName : list[string]) : FixedType
    {
      match (Manager.CoreEnv.LookupType(typeName))
      {
        | Some(ty) => FixedType.Class(ty, [])
        | None     => assert3(false)
      }
    }
  }
}
