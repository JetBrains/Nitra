using Nitra;
using Nitra.Utils;
using Nitra.Model;
using Nitra.ProjectSystem;
using Nitra.Runtime;
using Nitra.Typing;
using Nitra.Typing.TypingUtils;

using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

syntax module NitraSyntax : NitraLang
{
  using Nitra.Core;
  using Nitra.CStyleComments;
  using NitraLiterals;

  literal Pipe = "|";

  keyword regex IdentifierStartCharacter (IdentifierPartCharacters | '-')* rule S;

  regex PredefinedType = "void" | "int" | "string";

  regex KeywordToken = "as" | "syntax" | "declaration" | "declarations" | "ast" | "asts" | "extend" | "module"
                | "marker" | "map" | "token" | "field" | "span" | "alias" | "regex" | "literal" | "decompose"
                | "multiple" | "optional" | "abstract" | "in" | "out" | "inout" | "class" | "this"
                | "rule" | "precedence" | "using" | "namespace" | PredefinedType | "right-associative";

  [Keyword]
  token Keyword = Name=KeywordToken !IdentifierPartCharacters;

  [Reference]
  token Reference = !Keyword At="@"? IdentifierBody
  {
    Value() : string = GetText(IdentifierBody);
    Identifier() : Nitra.Model.Identifier = Nitra.Model.Identifier(this, IdentifierBody);
  }

  [Name]
  token Name = !Keyword At="@"? IdentifierBody
  {
    Value() : string = GetText(IdentifierBody);
    Identifier() : Nitra.Model.Identifier = Nitra.Model.Identifier(this, IdentifierBody);
  }

  token Text  = !Keyword At="@"? IdentifierBody
  {
    Value() : string = GetText(IdentifierBody);
    Identifier() : Nitra.Model.Identifier = Nitra.Model.Identifier(this, IdentifierBody);
  }

  [ExplicitSpaces]
  syntax QualifiedReference = Names=(Reference; s "." s)+
  {
    Identifiers() : list[Nitra.Model.Identifier] = Names.Item1.Identifiers();
    Parts() : list[string] = Names.Item1.MapToList(_.Value());
    CalcLocations() : list[Nitra.Location] = Names.Item1.MapToList(_.Location);
    LastIdentifier() : Nitra.Model.Identifier = Names.Item1[Names.Item1.Count - 1].Identifier();
  }

  ///////////////////////////////////////////////////////////////////////////
  //

  [StartRule]
  syntax Start = NamespaceMember*
  {
    CollectGlobalSymbols(rootNs : NamespaceSymbol) : void = foreach (topDecl in NamespaceMembers) topDecl.CollectGlobalSymbols(rootNs);
    [Cached] MakeContext(parent : Context) : Context
    {
      //assert2(false);
      def context2 = PassThrough(NamespaceMembers, parent, _.MakeContext(_));
      context2
    }
    TypeSyntaxMappings() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeSyntaxMappings();
    TypeAst() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeAst();
    TypeLanguage() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeLanguage();
    Typing() : void = foreach (topDecl in NamespaceMembers) topDecl.Typing();
    TypeSymbolMembers() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeSymbolMembers();
  }

  syntax NamespaceBody = NamespaceMember*
  {
    CollectGlobalSymbols(rootNs : NamespaceSymbol) : void = foreach (topDecl in NamespaceMembers) topDecl.CollectGlobalSymbols(rootNs);
    [Cached] MakeContext(parent : Context) : Context
    {
      def context2 = PassThrough(NamespaceMembers, parent, _.MakeContext(_));
      context2
    }
    TypeSyntaxMappings() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeSyntaxMappings();
    TypeAst() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeAst();
    TypeLanguage() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeLanguage();
    Typing() : void = foreach (topDecl in NamespaceMembers) topDecl.Typing();
    TypeSymbolMembers() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeSymbolMembers();
  }

  syntax Usings = outline_hiden outline_begin Using* outline_end_before
  {
    MakeContext(parent : Context) : Context = FoldThrough(Usings, parent, _.MakeContext(_));
  }

  syntax Using
  {
    [Cached] MakeContext(parent : Context) : Context;

    | UsingOpen  = "using" sm NamespaceOrType=QualifiedReference ";" nl
      {
        override MakeContext = OpenNamespaceOrTypeContext(parent, NamespaceOrType);
      }
    | UsingAlias = "using" Name sm "=" sm NamespaceOrType=QualifiedReference ";" nl
      {
        override MakeContext = NamespaceOrTypeAliasContext(parent, Name, NamespaceOrType);
      }
  }

  syntax NitraTypeArguments
  {
    Typing(context : Context) : list[NType];
    | Corners = "<" (NitraType; "," sm; ?)+ ">" { override Typing = this.NitraTypes.Item1.MapToList(t => t.Typing(context)[0]); }
    | Braces  = "[" (NitraType; "," sm; ?)+ "]" { override Typing = this.NitraTypes.Item1.MapToList(t => t.Typing(context)[0]); }
  }

  syntax NitraTypeName = Reference NitraTypeArguments?
  {
    Typing(context : Context) : TypeNamePart
    {
      def name = this.Reference.GetText();
      def env  = context.GetNemerleEnvironment();
      if (this.NitraTypeArgumentsOpt.HasValue)
        TypeNamePart(this.Reference.Location + this.NitraTypeArgumentsOpt.Location, name, this.NitraTypeArgumentsOpt.Value.Typing(context), env)
      else
        TypeNamePart(this.Reference.Location, name, [], env)
    }
  }

  syntax NitraType
  {
    Typing(context : Context) : NType * bool;

    | PredefinedType
      {
        override Typing
        {
          _ = context;
          def value = match (GetText(this.PredefinedType))
          {
            | "void"   => NPredefinedType.Void
            | "int"    => NPredefinedType.Int
            | "string" => NPredefinedType.String
            | _        => assert3(false)
          };
          (NType.Predefined(this.Location, value), false);
        }
      }
    | QualifiedType  = (NitraTypeName; ".")+
      {
        override Typing
        {
          def parts = LightList();
          foreach (t in this.NitraTypeNames.Item1)
            parts.Add(t.Typing(context));
          (NType.Qualified(this.Location, parts.ToNList()), false);
        }
      }
    | Braces         = "(" NitraType ")"
      {
        override Typing = (this.NitraType.Typing(context)[0], false);
      }

    precedence Function:
    | Func           = NitraType "->" NitraType    right-associative
      {
        override Typing = (NType.Func(this.Location, this.NitraType1.Typing(context)[0], this.NitraType2.Typing(context)[0]), false);
      }

    precedence Tuple:
    | Tuple          = NitraType "*" NitraType     right-associative
      {
        override Typing
        {
          def first = this.NitraType1.Typing(context)[0];
          match (this.NitraType2.Typing(context))
          {
            | (NType.Tuple(members), true) => (NType.Tuple(this.Location, first :: members), true)
            | (second, _)                  => (NType.Tuple(this.Location, [first, second]), true)
          }
        }
      }

    precedence RepeatModifier:
    | OptionList     = NitraType "*"
      {
        override Typing = (NType.OptionList(this.Location, this.NitraType.Typing(context)[0]), false);
      }
    | List           = NitraType "+"
      {
        override Typing = (NType.List(this.Location, this.NitraType.Typing(context)[0]), false);
      }
    | Option         = NitraType "?"
      {
        override Typing = (NType.Option(this.Location, this.NitraType.Typing(context)[0]), false);
      }
  }

  syntax LanguageMember
  {
    CollectGlobalSymbols(language : ParsedLanguageSymbol) : void;
    [Cached] MakeContext(parent : Context) : Context = parent;
    Typing() : void {}

    | Style = "style" sm Name sm StyleBody
      {
        override CollectGlobalSymbols
        {
          def symbol = ParsedStyleSymbol(this, language);
          _ = language.Node.AddAndReport(symbol, Name.Location);
          StyleBody.CollectProperties(symbol);
        }
      }

    | SpanClass = "span" sm "class" sm Name sm MatchTokensOpt=("regex" sm RegexExpression sm)? StyleReference
      {
        syntax StyleReference
        {
          CollectGlobalSymbols(language : ParsedLanguageSymbol, spanClass : SpanClassSymbol) : void;
          StyleRef(context : Context) : SymbolRef[StyleSymbol];

          | Reference = "=" sm QualifiedReference ";"
            {
              override CollectGlobalSymbols { _ = language; _ = spanClass; }
              override StyleRef = context.TryBind(QualifiedReference);
            }
          | StyleBody
            {
              [Cached] private MakeSymbol(spanClass : SpanClassSymbol) : ParsedStyleSymbol = ParsedStyleSymbol(spanClass.FirstLocation, spanClass.Name, spanClass.DeclaringLanguage);
              override CollectGlobalSymbols
              {
                def symbol = MakeSymbol(spanClass);
                _ = language.Node.AddAndReport(symbol, spanClass.FirstLocation);
                StyleBody.CollectProperties(symbol);
              }
              override StyleRef
              {
                _ = context;
                SymbolRef.Some(Symbol.FirstLocation, false, Symbol)
              }
            }
        }

        override CollectGlobalSymbols
        {
          def symbol = ParsedSpanClassSymbol(this, language);
          _ = language.Node.AddAndReport(symbol, Name.Location);
          StyleReference.CollectGlobalSymbols(language, symbol);
        }
        override MakeContext
        {
          when (MatchTokensOpt.HasValue)
            _ = MatchTokensOpt.Value.Item2.MakeContext(parent);
          parent
        }
        [Cached] private StyleRef() : SymbolRef[StyleSymbol] = StyleReference.StyleRef(this.Context);
        [Cached] private RegularRule() : option[RegularRule]
        {
          if (MatchTokensOpt.HasValue)
          {
            def rr = MatchTokensOpt.Value.Item2.Typing();
            rr.ValidateRegularRule(this.Context);
            Some(rr)
          }
          else
            None()
        }
        override Typing
        {
          _ = StyleRef();
          _ = RegularRule();
        }
      }

    | SyntaxModule              = "syntax" sm "module" sm Module=QualifiedReference RuleOpt=(sm "start" sm "rule" sm QualifiedReference)? ";"
      {
        [Cached] private MakeLanguage(language : ParsedLanguageSymbol) : ParsedLanguageSymbol = language;
        override CollectGlobalSymbols { _ = MakeLanguage(language); }
        override Typing
        {
          def syntaxModuleRef = this.Context.Bind.[SyntaxModuleSymbol](Module);
          when (syntaxModuleRef is SymbolRef.Some(syntaxModule))
          {
            Language.AddSyntaxModule(Module.Location, syntaxModule);
            when (RuleOpt.HasValue)
            {
              def ruleRef = syntaxModule.BindByHierarchy.[SyntaxRuleSymbol](RuleOpt.Value.Item3, this.Context);
              Language.SetStartRule(ruleRef);
            }
          }
        }
      }

    | FileExtension             = "extension" sm "=" sm Ext=FileExtension ";"
      {
        regex FileExtension = "." IdentifierPartCharacters+;

        override CollectGlobalSymbols = language.AddFileExtension(this.Location, GetText(Ext));
      }
    | Company                   = "company"          sm "=" sm Name=(!";" Any)* ";" { override CollectGlobalSymbols = language.SetCompany                 (this.Location, GetText(Name)); }
    | Description               = "description"      sm "=" sm Text=(!";" Any)* ";" { override CollectGlobalSymbols = language.SetLanguageDescription     (this.Location, GetText(Text)); }
    | Authors                   = "authors"          sm "=" sm Text=(!";" Any)* ";" { override CollectGlobalSymbols = language.SetAuthors                 (this.Location, GetText(Text)); }
    | Copyright                 = "copyright"        sm "=" sm Text=(!";" Any)* ";" { override CollectGlobalSymbols = language.SetCopyright               (this.Location, GetText(Text)); }
    | LicenseUrl                = "license" sm "url" sm "=" sm Text=(!";" Any)* ";" { override CollectGlobalSymbols = language.SetLicenseUrl              (this.Location, GetText(Text)); }
    | RequireLicenseAcceptance  = "require" sm "license" sm "acceptance" ";"        { override CollectGlobalSymbols = language.SetRequireLicenseAcceptance(this.Location, true); }
  }

  syntax StyleBody =  outline_begin_before nl "{" inl Properties=StyleProperty* d "}" outline_end_before nl
  {
    CollectProperties(style : ParsedStyleSymbol) : void = foreach (p in Properties) p.CollectProperties(style);
  }

  syntax StyleProperty
  {
    CollectProperties(style : ParsedStyleSymbol) : void;

    | ForegroundColor = "ForegroundColor" sm "=" sm Color ";" { override CollectProperties = style.SetForegroundColor(this.Location, Color.Value(style.Node.Project)); }
  }

  syntax Color
  {
    Value(_compilerMessages : ICompilerMessages) : System.Drawing.Color;

    | Hex   = HexColor
      {
        regex HexColor = '#' HexDigit{6};
        override Value = System.Drawing.Color.FromArgb(HexToInt(this, HexColor.StartPos + 1, HexColor.EndPos));
      }
    | Named = ColorName=Text
      {
        override Value
        {
          def colorName = ColorName.Value();
          def result    = System.Drawing.Color.FromName(colorName);
          unless (result.IsKnownColor)
            _compilerMessages.Error(ColorName, $"Unknown color name '$colorName'.");
          result
        }
      }
  }

  syntax AstInheritance = ":" sm BaseAsts=(QualifiedReference; "," sm)+
  {
    Typing(context : Context, isDeclaration : bool) : list[AstSymbol] = TypingUtils.BindAstInheritanceList(this.BaseAsts.Item1, context, isDeclaration);
  }

  syntax DependentProperty = Modifier Name sm ":" sm NitraType PropertyValue
  {
    token Modifier
    {
      Type() : DependentPropertyDirection * bool;
      | "in"    { override Type = (DependentPropertyDirection.In,  false); }
      | "out"   { override Type = (DependentPropertyDirection.Out, false); }
      | "inout" { override Type = (DependentPropertyDirection.In,  true ); }
    }

    syntax PropertyValue
    {
      ValueLocation() : Nitra.Location;
      HasValue() : bool;

      | Expression = sm "=" sm Expression ";" nl
        {
          override ValueLocation = Expression.Location;
          override HasValue = true;
        }
      | Empty = ";" nl
        {
          override ValueLocation = this.Location.FromStart();
          override HasValue = false;
        }
    }

    [Cached] Stage() : int = this.Context.TryGetContext.[AstDependentPropertyStageContext]()?.Stage;
    [Cached] MakeSymbol1(propertyContainer : PropertyContainerSymbol, direction : DependentPropertyDirection, isInOut : bool) : ParsedDependentPropertySymbol = ParsedDependentPropertySymbol(this, propertyContainer, direction, isInOut);
    [Cached] MakeSymbol2(propertyContainer : PropertyContainerSymbol) : ParsedDependentPropertySymbol = ParsedDependentPropertySymbol(this, propertyContainer, DependentPropertyDirection.Out, true);
    [Cached] MakeContext(parent : Context) : Context = parent;
    CollectGlobalSymbols(propertyContainer : PropertyContainerSymbol) : void
    {
      def (direction, isInOut) = this.Modifier.Type();
      _ = propertyContainer.Node.AddAndReport.[PropertySymbol](MakeSymbol1(propertyContainer, direction, isInOut), Name.Location);
      when (isInOut)
        _ = propertyContainer.Node.AddAndReport.[PropertySymbol](MakeSymbol2(propertyContainer), Name.Location);
    }
    [Cached] MakeType() : NType = this.NitraType.Typing(this.Context)[0];
    Typing() : void
    {
      _ = MakeType();
    }
    TypeProperties() : void
    {
      when (this.PropertyValue.HasValue())
      {
        def loc       = this.Modifier.Location + this.PropertyValue.ValueLocation();
        def statement = DependentStatement.Assign(loc, [Nitra.Model.Identifier(Name.Location, Symbol1.Name)], NemerleParser.Parse(this.PropertyValue, this.Context));
        TypingUtils.RegisterDependentStatement(this.Symbol1.PropertyContainer, statement, this.Context)
      }
    }
  }

  syntax DependentAssignStatement = Path=QualifiedReference sm "=" sm Expression ";"
  {
    Typing(propertyContainer : PropertyContainerSymbol, context : Context) : void
    {
      def loc       = Path.Location + Expression.Location;
      def statement = DependentStatement.Assign(loc, this.Path.Identifiers(), NemerleParser.Parse(this.Expression, context));
      TypingUtils.RegisterDependentStatement(propertyContainer, statement, context)
    }
  }

  syntax DependentCallStatement = Condition* Path=(Name ".")* Name=Reference OpenBrace="(" Arguments=(ArgumentExpression; "," sm)* CloseBrace=")" ";"
  {
    syntax Condition
    {
      Typing(context : Context) : DependentStatementCondition;

      | When   = "when" "(" Expression ")"
        {
          override Typing = DependentStatementCondition.When(this.Location, NemerleParser.Parse(this.Expression, context));
        }
      | Unless = "unless" "(" Expression ")"
        {
          override Typing = DependentStatementCondition.Unless(this.Location, NemerleParser.Parse(this.Expression, context));
        }
    }

    Typing(propertyContainer : PropertyContainerSymbol, context : Context) : void
    {
      def loc  = Location(this.Location.Source, Path.Span + CloseBrace);

      def path = array(this.Path.Count);
      foreach (item in this.Path with index)
        path[index] = item.Item1.Identifier();

      def arguments = array(this.Arguments.Item1.Count);
      foreach (item in this.Arguments.Item1 with index)
        arguments[index] = NemerleParser.Parse(item, context);

      def conditions = array(this.Conditions.Count);
      foreach (item in this.Conditions with index)
        conditions[index] = item.Typing(context);

      def statement = DependentStatement.Call(loc, path.ToNList(), this.Name.Identifier(), arguments.ToNList(), context.GetNemerleEnvironment(), conditions.ToNList());
      TypingUtils.RegisterDependentStatement(propertyContainer, statement, context)
    }
  }

  syntax DependentAddStatement = Path=QualifiedReference sm "|=" sm Expression ";"
  {
    Typing(propertyContainer : PropertyContainerSymbol, context : Context) : void
    {
      def loc       = Path.Location + Expression.Location;
      def statement = DependentStatement.Add(loc, this.Path.Identifiers(), NemerleParser.Parse(this.Expression, context));
      TypingUtils.RegisterDependentStatement(propertyContainer, statement, context)
    }
  }

  syntax StageScope = "stage" sm Number ":"
  {
    MakeContext(parent : Context) : Context = AstDependentPropertyStageContext(parent, Number.Value());
  }

  syntax SymbolDefinition = "sealed"? "symbol" outline_begin_before nl "{" inl Members=SymbolMember* d "}" outline_end_before nl
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    [Cached] CalcIsTypingAllowed(value : bool) : bool = value;
    CollectSymbolMembers(astSymbol : AstSymbol, symbolSymbolRef : SymbolRef[SymbolSymbol]) : void
    {
      mutable isTypingAllowed;

      if (astSymbol.IsDeclaration)
        when (symbolSymbolRef is SymbolRef.Some(symbolSymbol))
        {
          if (symbolSymbol.Declaration : object == astSymbol)
          {
            isTypingAllowed = true;

            foreach (member in Members)
              member.CollectGlobalSymbols(symbolSymbol);
            mutable memberContext = AstDependentPropertyStageContext(this.Context, 0);
            foreach (member in Members)
              memberContext = member.MakeContext(memberContext);
          }
          else
            this.Context.Error(this.Location.FromStart(), $"Symbol definition is not allowed in declaration with inherited sealed symbol '$(symbolSymbol.FullName)'.");
        }
      else
        this.Context.Error(this.Location.FromStart(), "Symbol definition is not allowed in AST.");

      _ = CalcIsTypingAllowed(isTypingAllowed);
    }
    TypeSymbolMembers() : void
    {
      when (IsTypingAllowed)
      {
        foreach (member in Members) member.Typing();
        foreach (member in Members) member.TypeProperties()
      }
    }
  }

  syntax SymbolMember
  {
    CollectGlobalSymbols(propertyContainer : PropertyContainerSymbol) : void;
    [Cached] MakeContext(parent : Context) : Context = parent;
    Typing() : void;
    TypeProperties() : void;

    | DependentProperty
      {
        override CollectGlobalSymbols = DependentProperty.CollectGlobalSymbols(propertyContainer);
        override MakeContext = DependentProperty.MakeContext(parent);
        override Typing = DependentProperty.Typing();
        override TypeProperties = DependentProperty.TypeProperties();
      }
    | DependentAssignStatement
      {
        [Cached] private MakePropertyContainer(propertyContainer : PropertyContainerSymbol) : PropertyContainerSymbol = propertyContainer;
        override CollectGlobalSymbols { _ = MakePropertyContainer(propertyContainer) }
        override Typing {}
        override TypeProperties = DependentAssignStatement.Typing(this.PropertyContainer, this.Context);
      }
    | DependentCallStatement
      {
        [Cached] private MakePropertyContainer(propertyContainer : PropertyContainerSymbol) : PropertyContainerSymbol = propertyContainer;
        override CollectGlobalSymbols { _ = MakePropertyContainer(propertyContainer) }
        override Typing {}
        override TypeProperties = DependentCallStatement.Typing(this.PropertyContainer, this.Context);
      }
    | DependentAddStatement
      {
        [Cached] private MakePropertyContainer(propertyContainer : PropertyContainerSymbol) : PropertyContainerSymbol = propertyContainer;
        override CollectGlobalSymbols { _ = MakePropertyContainer(propertyContainer) }
        override Typing {}
        override TypeProperties = DependentAddStatement.Typing(this.PropertyContainer, this.Context);
      }
    | StageScope
      {
        override CollectGlobalSymbols { _ = propertyContainer; }
        override MakeContext = StageScope.MakeContext(parent);
        override Typing {}
        override TypeProperties {}
      }
  }

  syntax AstBody = outline_begin_before nl "{" inl SymbolDefinition? Members=AstMember* d "}" outline_end_before nl
  {
    IsSymbolSealed() : bool = SymbolDefinitionOpt.HasValue && SymbolDefinitionOpt.Value.KwSealedOpt.HasValue;
    CollectGlobalSymbols(owner : AstSymbol) : void = foreach (member in Members) member.CollectGlobalSymbols(owner);
    [Cached] MakeContext(parent : Context) : Context
    {
      when (SymbolDefinitionOpt.HasValue)
        _ = SymbolDefinitionOpt.Value.MakeContext(parent);
      PassThrough(Members, parent, _.MakeContext(_));
    }
    Typing() : void = foreach (member in Members) member.Typing();
    TypeProperties() : void = foreach (member in Members) member.TypeProperties();
    CollectSymbolMembers(astSymbol : AstSymbol, symbolSymbolRef : SymbolRef[SymbolSymbol]) : void
    {
      when (SymbolDefinitionOpt.HasValue)
        SymbolDefinitionOpt.Value.CollectSymbolMembers(astSymbol, symbolSymbolRef);
    }
    TypeSymbolMembers() : void
    {
      when (SymbolDefinitionOpt.HasValue)
        SymbolDefinitionOpt.Value.TypeSymbolMembers();
      foreach (member in Members)
        member.TypeSymbolMembers();
    }
  }

  syntax AstMember
  {
    CollectGlobalSymbols(owner : AstSymbol) : void;
    [Cached] MakeContext(parent : Context) : Context = parent;
    Typing() : void;
    TypeProperties() : void;
    [Cached] Stage() : int = this.Context.TryGetContext.[AstDependentPropertyStageContext]()?.Stage;
    TypeSymbolMembers() : void {}

    | StructuralProperty = Name sm ":" sm NitraType ";" nl
      {
        private MakeSymbol(propertyContainer : PropertyContainerSymbol) : PropertySymbol = ParsedStructuralPropertySymbol(this, propertyContainer);
        override CollectGlobalSymbols
        {
          _ = owner.Node.AddAndReport.[PropertySymbol](MakeSymbol(owner), Name.Location);
        }
        [Cached] private MakeType() : NType = this.NitraType.Typing(this.Context)[0];
        [Cached] private MakeAstType() : AstType = TypingUtils.NTypeToAstType(MakeType(), this.Context);
        override Typing
        {
          _ = MakeType();
          _ = MakeAstType();
        }
        override TypeProperties {}
      }
    | DependentProperty
      {
        override CollectGlobalSymbols = DependentProperty.CollectGlobalSymbols(owner);
        override MakeContext = DependentProperty.MakeContext(parent);
        override Typing = DependentProperty.Typing();
        override TypeProperties = DependentProperty.TypeProperties();
      }
    | DependentAssignStatement
      {
        [Cached] private MakePropertyContainer(propertyContainer : PropertyContainerSymbol) : PropertyContainerSymbol = propertyContainer;
        override CollectGlobalSymbols { _ = MakePropertyContainer(owner) }
        override Typing {}
        override TypeProperties = DependentAssignStatement.Typing(this.PropertyContainer, this.Context);
      }
    | DependentCallStatement
      {
        [Cached] private MakePropertyContainer(propertyContainer : PropertyContainerSymbol) : PropertyContainerSymbol = propertyContainer;
        override CollectGlobalSymbols { _ = MakePropertyContainer(owner) }
        override Typing {}
        override TypeProperties = DependentCallStatement.Typing(this.PropertyContainer, this.Context);
      }
    | DependentAddStatement
      {
        [Cached] private MakePropertyContainer(propertyContainer : PropertyContainerSymbol) : PropertyContainerSymbol = propertyContainer;
        override CollectGlobalSymbols { _ = MakePropertyContainer(owner) }
        override Typing {}
        override TypeProperties = DependentAddStatement.Typing(this.PropertyContainer, this.Context);
      }
    | Decompose = "decompose" Name=Reference outline_begin_before nl "{" inl Properties=ProjectedProperty* d "}" outline_end_before nl
      {
        syntax ProjectedProperty = Name sm ":" NitraType ";" nl
        {
          CollectGlobalSymbols(owner : PropertyContainerSymbol) : void
          {
            def symbol = ParsedProjectedPropertySymbol(this, owner);
            _ = owner.Node.AddAndReport.[PropertySymbol](symbol, Name.Location);
          }
          [Cached] MakeType() : NType = this.NitraType.Typing(this.Context)[0];
          [Cached] MakeAstType() : AstType = TypingUtils.NTypeToAstType(MakeType(), this.Context);
          [Cached] MakeContext(parent : Context) : Context = parent;
          [Cached] MakeProjectionType(t : option[PropertyProjectionType]) : option[PropertyProjectionType] = t;
          Typing() : void
          {
            _ = MakeType();
            _ = MakeAstType();
          }
          TypeProjection(projectionSource : StructuralPropertySymbol, baseType : AstSymbol) : void
          {
            _ = MakeProjectionType(MakePropertyProjectionType(this.Type, projectionSource, baseType, this.Context))
          }
        }

        [Cached] private MakePropertyContainer(propertyContainer : PropertyContainerSymbol) : PropertyContainerSymbol = propertyContainer;
        override CollectGlobalSymbols
        { 
          _ = MakePropertyContainer(owner);
          foreach (property in Properties) property.CollectGlobalSymbols(owner);
        }
        override MakeContext = FoldThrough(Properties, parent, _.MakeContext(_));
        override Typing = foreach (property in Properties) property.Typing();
        override TypeProperties
        {
          def (projectionSource, baseType) = BindAstPropertyProjectionSource(this.PropertyContainer, this.Name, this.Context);
          foreach (property in Properties) property.TypeProjection(projectionSource, baseType)
        }
      }
    | StageScope
      {
        override CollectGlobalSymbols { _ = owner; }
        override MakeContext = StageScope.MakeContext(parent);
        override Typing {}
        override TypeProperties {}
      }
    | ChildAst = "|" sm AstModifier* Name AstInheritance? Body=AstBody?
      {
        [Cached] private MakeAstSymbol(owner : AstSymbol, compilerMessages : ICompilerMessages) : ParsedChildAstSymbol
        {
          unless (owner.IsAbstract)
            compilerMessages.Error(this, "Child AST is valid only in abstract AST body.");

          def (_, _, cardinality) = TypingUtils.TypeAstModifiers(this.AstModifiers, true, owner.IsDeclaration, compilerMessages);
          ParsedChildAstSymbol(this, owner, cardinality);
        }
        override CollectGlobalSymbols
        {
          def symbol = MakeAstSymbol(owner, owner.Node.Project);
          _ = owner.Node.AddAndReport.[AstSymbol](symbol, Name.Location);
          when (Body.HasValue)
            Body.Value.CollectGlobalSymbols(symbol);
        }
        override MakeContext
        {
          when (Body.HasValue)
          {
            def context1 = AstContext(parent, this.AstSymbol);
            def context2 = AstDependentPropertyStageContext(context1, 0);
            _ = Body.Value.MakeContext(context2);
          }
          parent
        }
        override Typing
        {
          _ = MakeParents();
          when (Body.HasValue)
            Body.Value.Typing();
        }
        override TypeProperties
        {
          this.AstSymbol.TypeInheritance();
          when (Body.HasValue)
            Body.Value.TypeProperties();
          when (this.AstSymbol.Symbol is SymbolRef.Some(s))
            s.TypeInheritance();
        }
        [Cached] private MakeParents() : list[AstSymbol] = AstSymbol.Owner :: TypingUtils.TypeAstInheritance(this.AstInheritanceOpt, this.Context, this.AstSymbol);
        override TypeSymbolMembers = when (Body.HasValue) Body.Value.TypeSymbolMembers();
      }
  }

  token AstModifier
  {
    IsAbstract(acc : bool, isExtensible : bool, compilerMessages : ICompilerMessages) : bool                                          { IgnoreParams(); acc }
    Cardinality(acc : AstCardinality, isDeclaration : bool, isAbstract : bool, compilerMessages : ICompilerMessages) : AstCardinality { IgnoreParams(); acc }

    | Abstract = "abstract" sm { override IsAbstract  = TypingUtils.TypeAstModifier_IsAbstract(this, acc, isExtensible, compilerMessages); }
    | Optional = "optional" sm { override Cardinality = TypingUtils.TypeAstModifier_Cardinality(this, acc, isDeclaration, isAbstract, compilerMessages, AstCardinality.Optional); }
    | Multiple = "multiple" sm { override Cardinality = TypingUtils.TypeAstModifier_Cardinality(this, acc, isDeclaration, isAbstract, compilerMessages, AstCardinality.Multiple); }
  }

  syntax NamespaceMember
  {
    CollectGlobalSymbols(ns : NamespaceSymbol) : void;
    [Cached] MakeContext(parent : Context) : Context;
    TypeSyntaxMappings() : void {}
    TypeAst() : void {}
    TypeLanguage() : void {}
    Typing() : void {}
    TypeSymbolMembers() : void {}

    | UsingOpen  = "using" sm NamespaceOrType=QualifiedReference ";" nl
      {
        override CollectGlobalSymbols { _ = ns; }
        override MakeContext = OpenNamespaceOrTypeContext(parent, NamespaceOrType);
      }

    | UsingAlias = "using" Name sm "=" sm NamespaceOrType=QualifiedReference ";" nl
      {
        override CollectGlobalSymbols { _ = ns; }
        override MakeContext = NamespaceOrTypeAliasContext(parent, Name, NamespaceOrType);
      }

    | Ast = Header sm Name AstInheritance? Body=AstBody
      {
        syntax Header
        {
          Modifiers(compilerMessages : ICompilerMessages) : bool * bool * AstCardinality;
          | Ast         = AstModifier* "ast"         { override Modifiers = TypingUtils.TypeAstModifiers(this.AstModifiers, false, false, compilerMessages); }
          | Declaration = AstModifier* "declaration" { override Modifiers = TypingUtils.TypeAstModifiers(this.AstModifiers, false, true,  compilerMessages); }
        }

        [Cached] private MakeAstSymbol(compilerMessages : ICompilerMessages) : AstSymbol
        {
          def (isDeclaration, isAbstract, cardinality) = this.Header.Modifiers(compilerMessages);
          if (isAbstract)
          {
            assert(cardinality == AstCardinality.Single);
            ParsedAbstractAstSymbol(this, isDeclaration)
          }
          else
            ParsedSimpleAstSymbol(this, isDeclaration, cardinality)
        }
        [Cached] private MakeParents() : list[AstSymbol] = TypingUtils.TypeAstInheritance(this.AstInheritanceOpt, this.Context, this.AstSymbol);
        override CollectGlobalSymbols
        {
          def symbol = MakeAstSymbol(ns.Node.Project);
          _ = ns.Node.AddAndReport.[AstSymbol](symbol, Name.Location);
          Body.CollectGlobalSymbols(symbol);
        }
        override MakeContext
        {
          def  context1 = AstContext(parent, this.AstSymbol);
          def  context2 = AstDependentPropertyStageContext(context1, 0);
          _ = Body.MakeContext(context2);
          parent
        }
        override Typing
        {
          _ = MakeParents();
          Body.Typing();
        }
        override TypeAst
        {
          this.AstSymbol.TypeInheritance();
          Body.TypeProperties();
          when (this.AstSymbol.Symbol is SymbolRef.Some(s))
            s.TypeInheritance();
        }
        override TypeSymbolMembers = Body.TypeSymbolMembers();
      }

    | MapSyntax = "map" sm "syntax" sm RuleName=QualifiedReference ParametersOpt=MapSyntaxParameters? sm "->" sm AstName=NitraType MapSyntaxBody
      {
        override CollectGlobalSymbols { _ = ns; }
        override MakeContext
        {
          def context = MapSyntaxContext(MapSyntaxEnteredScopeContext(parent));
          _ = MapSyntaxBody.MakeContext(context);
          context
        }
        [Cached] private MakeParameters() : list[SyntaxMappingParameterSymbol] = if (this.ParametersOpt.HasValue) this.ParametersOpt.Value.Typing(this.Context) else [];
        [Cached] private MakeReturnType() : AstType = TypingUtils.NTypeToAstTypeWithMessage(this.AstName, this.Context);
        [Cached] private MakeSymbol() : SymbolRef[SyntaxMappingSymbol]
        {
          if (this.Context.Bind.[SyntaxRuleSymbol](this.RuleName) is SymbolRef.Some(ruleSymbol))
          {
            def symbol = ParsedSyntaxMappingSymbol(this, ruleSymbol);
            ruleSymbol.AddSyntaxMapping(symbol);
            SymbolRef.Some(this.Location, false, symbol)
          }
          else SymbolRef.None(this.Location, false)
        }
        [Cached] private MakeExpr() : SyntaxMappingExpr
        {
          if (this.Symbol is SymbolRef.Some(syntaxMapping))
            this.MapSyntaxBody.TypeSyntaxMappings(syntaxMapping, syntaxMapping.ReturnType)
          else
            null
        }
        override Typing
        {
          _ = MakeSymbol();
          (this.Context :> MapSyntaxContext).Initialize(MakeParameters(), MakeReturnType());
        }
        override TypeSyntaxMappings
        {
          _ = MakeExpr();
        }
      }

    | Namespace   = "namespace"   sm NamespaceName outline_begin_before nl "{" inl NamespaceBody d "}" outline_end_before nl
      {
        [ExplicitSpaces]
        syntax NamespaceName = Path=(Name s "." s)* Name
        {
          CalcLocations() : list[Nitra.Location]
          {
            def path = List(Path.Count + 1);
            foreach (x in Path)
              path.Add(x.Item1.Location);
            path.Add(Name.Location);
            path.ToNList()
          }
        }

        [Cached] private MakeCurrentSymbol(ns : NamespaceSymbol) : NamespaceSymbol = MakeNamespaceSymbol(ns, NamespaceName.CalcLocations());
        override CollectGlobalSymbols = NamespaceBody.CollectGlobalSymbols(MakeCurrentSymbol(ns));
        override MakeContext
        {
          def nsContext = EnteredNamespaceContext(parent, CurrentSymbol);
          _ = NamespaceBody.MakeContext(nsContext);
          parent
        }
        override TypeSyntaxMappings = NamespaceBody.TypeSyntaxMappings();
        override Typing = NamespaceBody.Typing();
        override TypeAst = NamespaceBody.TypeAst();
        override TypeLanguage = NamespaceBody.TypeLanguage();
        override TypeSymbolMembers = NamespaceBody.TypeSymbolMembers();
      }

    | SyntaxModule = SyntaxModuleAttributes "syntax" sm "module" sm Name LanguageOpt=(sm ":" sm QualifiedReference)? outline_begin_before nl "{" inl Usings SyntaxModuleMember* d "}" outline_end_before nl
      {
        override CollectGlobalSymbols
        {
          def symbol = ParsedSyntaxModuleSymbol(this);
          _ = ns.Node.AddAndReport(symbol, Name.Location);
          foreach (decl in SyntaxModuleMembers)
            decl.CollectGlobalSymbols(symbol);
        }
        [Cached] private MakeInitialContext(contextToSave : SyntaxModuleContext) : SyntaxModuleContext = contextToSave;
        [Cached] private MakeFinalContext(contextToSave : Context) : Context = contextToSave;
        [Cached] private MakeLanguage() : SymbolRef[LanguageSymbol] = TypingUtils.TypeLanguageInheritance(LanguageOpt, Context, null);
        override MakeContext
        {
          def context1 = MakeInitialContext(SyntaxModuleContext(parent, Name));
          def context2 = Usings.MakeContext(context1);
          def context3 = SyntaxModuleBodyContext(context2);
          def _context4 = MakeFinalContext(FoldThrough(SyntaxModuleMembers, context3, _.MakeContext(_)));
          parent
        }
        [Cached] private MakeTokenLiteralNames() : Map[string, Nitra.Model.Identifier] = FoldThrough(SyntaxModuleMembers, Map(), _.GetTokenLiteralNames(_));
        override TypeLanguage
        {
          _ = MakeLanguage();
        }
        override TypeSyntaxMappings    = foreach (decl in SyntaxModuleMembers) decl.TypeSyntaxMappings();
        override Typing
        {          
          _ = MakeTokenLiteralNames();
          foreach (decl in SyntaxModuleMembers)
            decl.Typing();
        }
      }

    | Language = "language" sm Name ParentOpt=(sm ":" sm QualifiedReference)? outline_begin_before nl "{" inl Members=LanguageMember* d "}" outline_end_before nl
      {
        [Cached] private MakeSymbol() : ParsedLanguageSymbol = ParsedLanguageSymbol(this);
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol();
          _ = ns.Node.AddAndReport(symbol, Name.Location);
          foreach (member in Members)
            member.CollectGlobalSymbols(symbol);
        }
        override MakeContext
        {
          def context = LanguageContext(parent, Symbol);
          foreach (member in Members)
            _ = member.MakeContext(context);
          parent
        }
        [Cached] private Parent() : SymbolRef[LanguageSymbol] = TypingUtils.TypeLanguageInheritance(ParentOpt, Context, Symbol);
        override TypeLanguage
        {
          _ = Parent();
          this.Symbol.TypeInheritance();
          foreach (member in Members)
            member.Typing();
        }
      }
  }

  syntax SyntaxModuleAttribute
  {
    Options(inOptions : SyntaxModuleOptions) : SyntaxModuleOptions = inOptions;
    [Cached] MakeContext(_parent : Context) : Context = _parent;

    | ExplicitSpaces = AttributeName="ExplicitSpaces" { override Options = inOptions.SetExplicitSpaces(this, true); }
    | ImplicitSpaces = AttributeName="ImplicitSpaces" { override Options = inOptions.SetExplicitSpaces(this, false); }
  }

  syntax SyntaxModuleAttributeList = "[" (SyntaxModuleAttribute; ","sm)+ "]" sm
  {
    Options(inOptions : SyntaxModuleOptions) : SyntaxModuleOptions = FoldThrough(SyntaxModuleAttributes.Item1, inOptions, _.Options(_));
    MakeContext(parent : Context) : Context = FoldThrough(SyntaxModuleAttributes.Item1, parent, _.MakeContext(_));
  }

  syntax SyntaxModuleAttributes    = SyntaxModuleAttributeList*
  {
    [Cached] Options(inOptions : SyntaxModuleOptions) : SyntaxModuleOptions = FoldThrough(SyntaxModuleAttributeLists, inOptions, _.Options(_));
    [Cached] MakeContext(parent : Context) : Context = FoldThrough(SyntaxModuleAttributeLists, parent, _.MakeContext(_));
  }

  syntax RuleAttribute
  {
    Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = inOptions;
    [Cached] MakeContext(_parent : Context) : Context = _parent;

    | Start                  = AttributeName="StartRule" { override Options = inOptions.SetStart(this, true); }
    | "Arity" "(" Number ")" { override Options = inOptions.SetArity(this, Number.Value()); }
    | "Prefix"               { override Options = inOptions.SetOperatorInfo(this, OperatorInfo.Prefix); }
    | "Postfix"              { override Options = inOptions.SetOperatorInfo(this, OperatorInfo.Postfix); }
    | "Infix"                { override Options = inOptions.SetOperatorInfo(this, OperatorInfo.Infix); }
    | SpanClass              = AttributeName="SpanClass" "(" Reference ")"
      {
        override Options
        {
          def languageRef = Context.GetContext.[SyntaxModuleContext]().SyntaxModuleSymbol.Language;
          if (languageRef is SymbolRef.Some(language))
          {
            def name = this.Reference.Value();
            if (language.LookupSpanClass(name) is VSome(spanClass))
              inOptions.SetSpanClass(this.Reference, spanClass)
            else
            {
              Context.Error(this.Reference, $"Unbound name '$name'.");
              inOptions
            }
          }
          else
            inOptions
        }
      }
    | ExplicitSpaces              = AttributeName="ExplicitSpaces"              { override Options = inOptions.SetExplicitSpaces(this, true); }
    | ImplicitSpaces              = AttributeName="ImplicitSpaces"              { override Options = inOptions.SetExplicitSpaces(this, false); }
    | SuppressTrailingSpaces      = AttributeName="SuppressTrailingSpaces"      { override Options = inOptions.SetSuppressTrailingSpaces(this, true); }
    | AllowTrailingSpaces         = AttributeName="AllowTrailingSpaces"         { override Options = inOptions.SetSuppressTrailingSpaces(this, false); }
    | NoParseTree                 = AttributeName="NoParseTree"                 { override Options = inOptions.SetNoParseTree(this, true); }
    | KeyToken                    = AttributeName="Key"                         { override Options = inOptions.SetKeyToken(this, true); }
    | Keyword                     = AttributeName="Keyword"                     { override Options = inOptions.SetKeyword(this, true); }
    | Reference                   = AttributeName="Reference"                   { override Options = inOptions.SetReference(this, true); }
    | Name                        = AttributeName="Name"                        { override Options = inOptions.SetName(this, true); }
    | DynamicSyntaxExtender       = AttributeName="DynamicSyntaxExtender"       { override Options = inOptions.SetDynamicSyntaxExtender(this, true); }
    | DynamicSyntaxExtentionPoint = AttributeName="DynamicSyntaxExtentionPoint" { override Options = inOptions.SetDynamicSyntaxExtentionPoint(this, true); }
  }

  syntax RuleAttributeList = "[" (RuleAttribute; ","sm)+ "]" sm
  {
    Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = FoldThrough(RuleAttributes.Item1, inOptions, _.Options(_));
    MakeContext(parent : Context) : Context = FoldThrough(RuleAttributes.Item1, parent, _.MakeContext(_));
  }

  syntax RuleAttributes    = RuleAttributeList*
  {
    [Cached] Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = FoldThrough(RuleAttributeLists, inOptions, _.Options(_));
    [Cached] MakeContext(parent : Context) : Context = FoldThrough(RuleAttributeLists, parent, _.MakeContext(_));
  }

  [StartRule]
  syntax SyntaxModuleMember
  {
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void = _ = owner;
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetPrecedenceRelations() : PrecedenceRelations * list[Precedence] = (null, null);
    TypeSyntaxMappings() : void {}
    Typing() : void {}

    GetTokenLiteralNames(result : Map[string, Nitra.Model.Identifier]) : Map[string, Nitra.Model.Identifier] = result;

    | RegexRule
      {
        override CollectGlobalSymbols = RegexRule.CollectGlobalSymbols(owner);
        override MakeContext          = RegexRule.MakeContext(parent);
        override TypeSyntaxMappings   = RegexRule.TypeSyntaxMappings();
        override Typing               = RegexRule.Typing();
      }
    | SimpleRule
      {
        override CollectGlobalSymbols = SimpleRule.CollectGlobalSymbols(owner);
        override MakeContext          = SimpleRule.MakeContext(parent);
        override TypeSyntaxMappings   = SimpleRule.TypeSyntaxMappings();
        override Typing               = SimpleRule.Typing();
      }
    | ExtensibleRule
      {
        override CollectGlobalSymbols    = ExtensibleRule.CollectGlobalSymbols(owner);
        override MakeContext             = ExtensibleRule.MakeContext(parent);
        override GetPrecedenceRelations  = ExtensibleRule.PrecedenceRelations;
        override TypeSyntaxMappings      = ExtensibleRule.TypeSyntaxMappings();
        override Typing                  = ExtensibleRule.Typing();
      }
    | Marker              = "marker"              sm Name                                                   ";"nl
      {
        override CollectGlobalSymbols = _ = owner.Node.AddAndReport(ParsedMarkerSymbol(Name, owner), Location);
      }
    | ExtendRule          = Header sm (Name sm "=" sm)? BaseName=QualifiedReference RuleBody
      {
        syntax Header
        {
          IsToken() : bool;
          | Token  = "extend" sm "token"  { override IsToken = true;  }
          | Syntax = "extend" sm "syntax" { override IsToken = false; }
        }

        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedExtendSyntaxSymbol = ParsedExtendSyntaxSymbol(this, owner, this.Header.IsToken());
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol(owner);
          _ = owner.Node.AddAndReport.[ExtendSyntaxSymbol](symbol, Location);
          this.RuleBody.CollectGlobalSymbols(symbol);
        }
        override MakeContext
        {
          def context = RuleDeclarationSiteContext(parent, Symbol);
          _ = this.RuleBody.MakeContext(PrecedenceZeroContext(PrecedenceStartContext(context, this.Symbol)));
          parent
        }
        [Cached] private MakePrecedenceRelationsCached(context : Context) : PrecedenceRelations * list[Precedence]
        {
          PrecedenceContext.MakePrecedenceRelations(context)
        }
        override GetPrecedenceRelations = PrecedenceRelationsCached;
        override TypeSyntaxMappings     = this.RuleBody.TypeSyntaxMappings();
        [Cached] private MakeBaseRuleRef() : SymbolRef[ExtensibleRuleSymbol] = this.Context.Bind.[ExtensibleRuleSymbol](BaseName);
        override Typing
        {
          def baseRule = MakeBaseRuleRef();
          when (baseRule is Some(symbol) when symbol.Options.IsTokenRule != this.Symbol.IsToken)
          {
            def msg = if (symbol.Options.IsTokenRule) "Can't extend token with syntax rule."
                      else "Can't extend syntax rule with token.";
            this.Context.Error(BaseName, msg);
          }
          this.RuleBody.Typing();
          _ = MakePrecedenceRelationsCached(this.RuleBody.Context);
        }
      }
    | RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | TokenLiteral = "literal" sm Name=Text sm "="  sm (StringLiteral; ","sm)+ ";"nl
      {
        override GetTokenLiteralNames
        {
          def name = Name.Identifier();
          FoldThrough(StringLiterals.Item1, result, (strLit, result) => result.Replace(strLit.Value(), name))
        }
        override MakeContext = TokenLiteralContext(parent, Name, StringLiterals.Item1);
      }
    | KeywordRegex        = "keyword" sm "regex"  sm MatchTokens=RegexExpression sm "rule" sm QualifiedReference ";"nl
      {
        override MakeContext
        {
          def context = KeywordRegexContext(parent, MatchTokens, QualifiedReference);
          _ = MatchTokens.MakeContext(context);
          context
        }
      }
  }

  syntax RuleAlias = "alias" sm Name sm "=" sm RuleExpression ";"nl
  {
    [Cached] private MakeSymbol(project : Project) : RuleAliasSymbol
    {
      def symbol = ParsedRuleAliasSymbol(this);
      project.AddSymbolDef(symbol, Name.Location);
      symbol
    }
    MakeContext(parent : Context) : Context = RuleAliasContext(parent, MakeSymbol(parent.Project));
  }

  syntax MapSyntaxCode
  {
    MakeExpr(context : Context) : SyntaxMappingExpr = SyntaxMappingExpr.Code(this, NemerleParser.Parse(this, context));
    | Block
    | Expression = Expression ";"
  }

  syntax MapSyntaxExpression
  {
    [Cached] MakeContext(parent : Context) : Context;
    [Cached] MakeType(ruleSymbol : SyntaxRuleSymbol, typeHintOpt : ValueOption[AstType]) : SyntaxMappingType;
    Expression(ruleSymbol : SyntaxRuleSymbol, astType : AstType) : SyntaxMappingExpr = SyntaxMappingTyper.MakeExpression(MakeType(ruleSymbol, VSome(astType)), astType, this.Context);

    | Braces = "(" Expr=MapSyntaxExpression ")"
      {
        override MakeContext { _ = Expr.MakeContext(parent); parent }
        override MakeType   = this.Expr.MakeType(ruleSymbol, typeHintOpt);
      }
    | This = "this"
      {
        override MakeContext = parent;
        override MakeType    = SyntaxMappingTyper.TypeThis(this, ruleSymbol, typeHintOpt);
      }
    | Identifier = !(ReservedWords !IdentifierPartCharacters) Reference
      {
        regex ReservedWords = "Some" | "None" | "this";
        override MakeContext = parent;
        override MakeType    = SyntaxMappingTyper.TypeIdentifier(this, ruleSymbol, typeHintOpt);
      }
    | Ast        = QualifiedReference outline_begin_before nl OpenBrace="{" inl Members=MapSyntaxExpressionAstMember* d CloseBrace="}" outline_end_before nl
      {
        override MakeContext { foreach (member in this.Members) _ = member.MakeContext(parent); parent }
        override MakeType    = SyntaxMappingTyper.TypeAst(this, ruleSymbol, typeHintOpt);
      }
    | List       = "[" (ItemExpr=MapSyntaxExpression; ",")* "]"
      {
        override MakeContext { foreach (member in this.ItemExprs.Item1) _ = member.MakeContext(parent); parent }
        override MakeType    = SyntaxMappingTyper.TypeList(this, ruleSymbol, typeHintOpt);
      }
    | OptionSome = "Some" "(" ValueExpr=MapSyntaxExpression ")"
      {
        override MakeContext { _ = ValueExpr.MakeContext(parent); parent }
        override MakeType    = SyntaxMappingTyper.TypeOptionSome(this, ruleSymbol, typeHintOpt);
      }
    | OptionNone = "None" "(" ")"
      {
        override MakeContext = parent;
        override MakeType    { IgnoreParams(); SyntaxMappingType.Option(this.Location, None()); }
      }
    | Match = "match" "(" Expr=MapSyntaxExpression ")" outline_begin_before nl "{" inl ("|" sm)? (MatchCase; inl "|")+ "}" outline_end_before nl
      {
        syntax MatchCase
        {
          [Cached] MakeContext(parent : Context) : Context;
          MakeType(ruleType : RuleType, ruleSymbol : SyntaxRuleSymbol, typeHintOpt : ValueOption[AstType]) : Location * ParseTreePattern * SyntaxMappingType;

          | Inline = Pattern sm "=" Code=MapSyntaxCode
            {
              [Cached] private MakeExpr() : SyntaxMappingExpr = Code.MakeExpr(this.Context);
              override MakeContext = ParseTreePatternVariableContext(parent);
              override MakeType
              {
                _ = ruleSymbol;
                def patternType = this.Pattern.Typing(ruleType, this.Context);
                if (typeHintOpt is VSome(typeHint))
                  (this.Location, patternType, SyntaxMappingType.Ast(Code.Location, typeHint, MakeExpr()))
                else
                  (this.Location, patternType, SyntaxMappingType.Undefined(Code.Location))
              }
            }

          | Expression = Pattern sm "->" Expr=MapSyntaxExpression
            {
              override MakeContext
              {
                def context = ParseTreePatternVariableContext(parent);
                _ = this.Expr.MakeContext(context);
                context
              }
              override MakeType
              {
                def patternType = this.Pattern.Typing(ruleType, this.Context);
                def exprType    = this.Expr.MakeType(ruleSymbol, typeHintOpt);
                (this.Location, patternType, exprType)
              }
            }
        }

        override MakeContext { _ = this.Expr.MakeContext(parent); foreach (item in this.MatchCases.Item1) _ = item.MakeContext(parent); parent }
        override MakeType = SyntaxMappingTyper.TypeMatch(this, ruleSymbol, typeHintOpt);
      }
    | Fold = "fold" "(" ItemName=Name                 sm "in" sm ItemExpr=MapSyntaxExpression
                    ";" sm AccumulatorName1=Name      sm "="  sm InitExpr=MapSyntaxExpression
                    ";" sm AccumulatorName2=Reference sm "="  sm EachExpr=MapSyntaxExpression
                    ")"
      {
        [Cached] private MakeAccumulatorSymbol() : AstVariableSymbol = ParsedAccumulatorAstVariableSymbol(this);
        override MakeContext
        {
          _ = ItemExpr.MakeContext(parent);
          _ = InitExpr.MakeContext(parent);

          def context1 = ParseTreePatternVariableContext(parent);
          def context2 = AstVariableContext(context1, MakeAccumulatorSymbol());
          _ = EachExpr.MakeContext(context2);
          parent
        }
        [Cached] private MakeReturnType(returnType : AstType) : AstType = returnType;
        override MakeType = SyntaxMappingTyper.TypeFold(this, ruleSymbol, typeHintOpt);
      }
    | DefineVariable = "let" sm Name sm ":" sm NitraType sm "=" sm Expr=MapSyntaxExpression sm "in" nl Body=MapSyntaxExpression
      {
        [Cached] private MakeVariableSymbol() : AstVariableSymbol = ParsedAstVariableSymbol(this);
        [Cached] private MakeVariableType() : AstType = TypingUtils.NTypeToAstTypeWithMessage(this.NitraType, this.Context);
        [Cached] private MakeVariableExpression(ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingExpr = Expr.Expression(ruleSymbol, MakeVariableType());
        override MakeContext
        {
          def context = AstVariableContext(parent, MakeVariableSymbol());
          _ = Expr.MakeContext(context);
          Body.MakeContext(context)
        }
        override MakeType
        {
          _ = MakeVariableExpression(ruleSymbol);
          def body = Body.MakeType(ruleSymbol, typeHintOpt);
          SyntaxMappingType.DefineVariable(this, this.VariableSymbol, body)
        }
      }

    precedence TypeHint:
    | TypeHint = Expr=MapSyntaxExpression sm ":" sm NitraType
      {
        override MakeContext = Expr.MakeContext(parent);
        override MakeType    = SyntaxMappingTyper.TypeTypeHint(this, ruleSymbol, typeHintOpt);
      }

    precedence Call:
    | Call = Expr=MapSyntaxExpression "(" (ArgumentExpr=MapSyntaxExpression; "," sm)* ")"
      {
        override MakeContext { _ = Expr.MakeContext(parent); foreach (item in ArgumentExprs.Item1) _ = item.MakeContext(parent); parent }
        override MakeType    = SyntaxMappingTyper.TypeCall(this, ruleSymbol, typeHintOpt);
      }

    precedence MemberAccess:
    | MemberAccess = Expr=MapSyntaxExpression "." Reference
      {
        override MakeContext { _ = Expr.MakeContext(parent); parent }
        override MakeType    = SyntaxMappingTyper.TypeMemberAccess(this, ruleSymbol, typeHintOpt);
      }
  }

  syntax MapSyntaxExpressionAstMember
  {
    [Cached] MakeContext(parent : Context) : Context;
    GetSyntaxMappingField(astSymbol : AstSymbol, ruleSymbol : SyntaxRuleSymbol) : ValueOption[SyntaxMappingField];

    | ParseTreeFieldExpressionMapping = Expr=MapSyntaxExpression sm "->" sm AstPropertyName=Reference ";"
      {
        override MakeContext { _ = Expr.MakeContext(parent); parent }
        override GetSyntaxMappingField
        {
          match (TypingUtils.BindProperty(astSymbol, this.AstPropertyName, this.Context))
          {
            | SymbolRef.Some(StructuralPropertySymbol(AstType = Void) as p) =>
              def name = p.Name;
              def type = p.Type;
              this.Context.Error(this, $"Type '$type' of property '$name' is not AST.");
              VNone()

            | SymbolRef.Some(StructuralPropertySymbol as p) =>
              def expr = this.Expr.Expression(ruleSymbol, p.AstType);
              VSome(SyntaxMappingField(this.Location, p, expr))

            | SymbolRef.Some =>
              this.Context.Error(this, "Expected structural AST property.");
              VNone()

            | SymbolRef.None => VNone()
          }
        }
      }
    | ParseTreeFieldCodeMapping = FieldName=Reference sm "=" sm Code=MapSyntaxCode
      {
        override MakeContext = parent;
        override GetSyntaxMappingField
        {
          _ = ruleSymbol;
          match (TypingUtils.BindProperty(astSymbol, this.FieldName, this.Context))
          {
            | SymbolRef.Some(StructuralPropertySymbol as p) =>
              def expr = this.Code.MakeExpr(this.Context);
              VSome(SyntaxMappingField(this.Location, p, expr))

            | SymbolRef.Some =>
              this.Context.Error(this, "Expected structural AST property.");
              VNone()

            | SymbolRef.None => VNone()
          }
        }
      }
  }

  syntax Pattern
  {
    Typing(ruleType : RuleType, context : Context) : ParseTreePattern;

    | Identifier=Reference
      {
        override Typing                   = PatternTyper.TypeIdentifier(this.Location, this.Reference.Identifier(), ruleType, context);
      }
    | Ctor  = Identifier=Reference "(" (Pattern; "," sm)* ")"
      {
        override Typing                   = PatternTyper.TypeCtor(this.Location, this.Identifier.Identifier(), this.Patterns.Item1, ruleType, context);
      }
    | Tuple = "(" (Pattern; "," sm)* ")"
      {
        override Typing       = PatternTyper.TypeTuple(this.Location, this.Patterns.Item1, ruleType, context);
      }

    precedence List:
    | List1 = Pattern ^ List s "::" s Pattern ^ +List
      {
        override Typing = PatternTyper.TypeList1(this.Location, this.Pattern1, this.Pattern2, ruleType, context);
      }
    precedence 0:

    | List2 = "[" (Pattern; "," sm)* "]"
      {
        override Typing = PatternTyper.TypeList2(this.Location, this.Patterns.Item1, ruleType, context);
      }
  }

  syntax MapSyntaxParameters = "(" (RuleMethodParam; "," sm)* ")"
  {
    Typing(context : Context) : list[SyntaxMappingParameterSymbol] = this.RuleMethodParams.Item1.MapToList(_.TypeForMapSyntax(context));
  }

  syntax MapSyntaxBody
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    TypeSyntaxMappings(syntaxMapping : SyntaxMappingSymbol, returnType : AstType) : SyntaxMappingExpr;

    | Empty = ";"
      {
        override TypeSyntaxMappings
        {
          _ = returnType;
          if (syntaxMapping.DeclaringRule is ExtensibleRuleSymbol)
            null
          else
          {
            this.Context.Error(this, "Empty mapping expression is valid only on extensible rules");
            SyntaxMappingExpr.Error(this)
          }
        }
      }
    | Expression1 = outline_begin_before nl "{" Expr=MapSyntaxExpression "}" outline_end_before nl
      {
        override MakeContext { _ = this.Expr.MakeContext(parent); parent }
        override TypeSyntaxMappings
        {
          if (syntaxMapping.DeclaringRule is ExtensibleRuleSymbol)
          {
            this.Context.Error(this, "Mapping expression is not valid on extensible rules");
            null
          }
          else
            this.Expr.Expression(syntaxMapping.DeclaringRule, returnType)
        }
      }
    | Expression2 = "->" Expr=MapSyntaxExpression
      {
        override MakeContext { _ = this.Expr.MakeContext(parent); parent }
        override TypeSyntaxMappings
        {
          if (syntaxMapping.DeclaringRule is ExtensibleRuleSymbol)
          {
            this.Context.Error(this, "Mapping expression is not valid on extensible rules");
            null
          }
          else
            this.Expr.Expression(syntaxMapping.DeclaringRule, returnType)
        }
      }
    | Inline = sm "=" sm Code=MapSyntaxCode
      {
        override TypeSyntaxMappings { _ = syntaxMapping; _ = returnType; this.Code.MakeExpr(this.Context); }
      }
    | Extensions = outline_begin_before nl OpenBrace="{" inl Extensions=MapExtension+ d CloseBrace="}" outline_end_before nl
      {
        syntax MapExtension = "|" Reference Body=MapSyntaxBody
        {
          [Cached] MakeContext(parent : Context) : Context { _ = Body.MakeContext(parent); parent; }
          TypeSyntaxMappings(baseRule : ExtensibleRuleSymbol, parameters : list[SyntaxMappingParameterSymbol], returnType : AstType) : void
          {
            when (Utils.BindByHierarchy.[ExtensionRuleSymbol](baseRule, this.Reference, this.Context) is SymbolRef.Some(extensionRule))
            {
              def returnType2 =
                if (returnType is AstType.Ast(astSymbol))
                {
                  def ignoredErrors = CompilerMessageList();
                  if (Utils.BindByHierarchy.[AstSymbol](astSymbol, this.Reference, ignoredErrors) is SymbolRef.Some(extensionAst))
                    AstType.Ast(this.Reference.Location, extensionAst)
                  else
                    returnType;
                }
                else
                  returnType;

              def symbol = ChemicalSyntaxMappingSymbol(this.Reference.Location, extensionRule, parameters, returnType);
              extensionRule.AddSyntaxMapping(symbol);
              def expr   = this.Body.TypeSyntaxMappings(symbol, returnType2);
              symbol.SetExpression(expr);
            }
          }
        }

        override MakeContext
        {
          def context = parent;
          foreach (extension in Extensions)
            _ = extension.MakeContext(context);
          context
        }
        override TypeSyntaxMappings
        {
          if (syntaxMapping.DeclaringRule is ExtensibleRuleSymbol as baseRule)
          {
            foreach (extension in Extensions)
              extension.TypeSyntaxMappings(baseRule, syntaxMapping.Parameters, returnType);
            null
          }
          else
          {
            def loc = Location(this.Location.Source, this.OpenBrace);
            this.Context.Error(loc, "Extension rule mapping expressions is valid only in extensible rules.");
            SyntaxMappingExpr.Error(this)
          }
        }
      }
    | PerMember = outline_begin_before nl OpenBrace="{" inl Members=MapSyntaxExpressionAstMember* d CloseBrace="}" outline_end_before nl
      {
        override MakeContext
        {
          def context = parent;
          foreach (member in Members)
            _ = member.MakeContext(context);
          context
        }
        override TypeSyntaxMappings
        {
          if (syntaxMapping.DeclaringRule is ExtensibleRuleSymbol)
          {
            when (Members.Count > 0)
            {
              def loc = Location(this.Location.Source, this.OpenBrace);
              this.Context.Error(loc, "Inline member mapping expressions is not valid on extensible rules");
            }
            null
          }
          else
          {
            if (returnType is Ast(astSymbol))
            {
              def mappingFields = List();
              foreach (member in Members)
                when (member.GetSyntaxMappingField(astSymbol, syntaxMapping.DeclaringRule) is VSome(mappingField))
                  mappingFields.Add(mappingField);

              TypingUtils.CreateAstCtor(this, astSymbol, mappingFields, Location(this.Location.Source, this.CloseBrace), this.Context)
            }
            else
            {
              def loc = Location(this.Location.Source, this.OpenBrace);
              this.Context.Error(loc, $"Inline member mapping expressions is not valid for AST type '$(returnType)'.");
              SyntaxMappingExpr.Error(this)
            }
          }
        }
      }
  }

  syntax RegexRule = RuleAttributes "regex" sm Name sm "=" sm RegexExpression RuleBody
  {
    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedRegularRuleSymbol = ParsedRegularRuleSymbol(this, owner);
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      match (owner : object)
      {
        | ExtendSyntaxSymbol => owner.Node.Project.Error(this, "Regular rule declaration is not allowed here.")
        | _ => ()
      }
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      this.RuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context = RuleDeclarationSiteContext(parent, Symbol);
      _ = this.RuleAttributes.MakeContext(context);
      _ = this.RegexExpression.MakeContext(context);
      _ = this.RuleBody.MakeContext(context);
      parent
    }
    [Cached] private Regex() : RegularRule = RegexExpression.Typing();
    TypeSyntaxMappings() : void    = this.RuleBody.TypeSyntaxMappings();
    Typing() : void
    {
      _ = Regex();
      _ = this.RuleBody.Typing();
    }
  }

  syntax SimpleRule = RuleAttributes Header sm Name sm "=" sm Expression=RuleExpression RuleBody
  {
    token Header
    {
      Kind() : SimpleRuleKind; Title() : string;
      | Syntax = "syntax" { override Kind = SimpleRuleKind.Normal; override Title = "Simple rule"; }
      | Token  = "token"  { override Kind = SimpleRuleKind.Token;  override Title = "Token rule"; }
      | Void   = "void"   { override Kind = SimpleRuleKind.Void;   override Title = "Void rule"; }
    }

    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : SimpleRuleSymbol
    {
      match (this.Header.Kind())
      {
        | Normal => ParsedSimpleRuleSymbol(this, owner)
        | Token  => ParsedTokenRuleSymbol(this, owner)
        | Void   => ParsedVoidRuleSymbol(this, owner);
      }
    }
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      match (owner : object)
      {
        | ExtendSyntaxSymbol
        | RegularRuleSymbol
        | SimpleRuleSymbol(Kind = SimpleRuleKind.Token) when this.Header.Kind() != SimpleRuleKind.Token =>
          def title = this.Header.Title();
          owner.Node.Project.Error(this, $"$title declaration is not allowed here.")

        | _ => ()
      }
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      this.RuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context = RuleDeclarationSiteContext(parent, Symbol);
      _ = this.RuleAttributes.MakeContext(context);
      _ = this.RuleBody.MakeContext(context);
      parent
    }
    [Cached] private MakeTypedRule()   : Rule.Sequence = TypeRuleExpression(this.Symbol.Options, this.RuleBody.Context, Expression.Typing(None(), PrecedenceInfo.None, None(), this.RuleBody.Context, this.Symbol.Options));
    TypeSyntaxMappings() : void    = this.RuleBody.TypeSyntaxMappings();
    Typing() : void
    {
      _ = MakeTypedRule();
      this.RuleBody.Typing();
    }
  }

  syntax ExtensibleRule = RuleAttributes Header sm Name RuleBody
  {
    token Header
    {
      IsToken() : bool; Title() : string;
      | Syntax = "syntax" { override IsToken = false; override Title = "Extensible rule"; }
      | Token  = "token"  { override IsToken = true;  override Title = "Extensible token rule"; }
    }

    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ExtensibleRuleSymbol
    {
      if (this.Header.IsToken())
        ParsedExtensibleTokenRuleSymbol(this, owner)
      else
        ParsedExtensibleRuleSymbol(this, owner)
    }
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      match (owner : object)
      {
        | ExtendSyntaxSymbol
        | RegularRuleSymbol
        | SimpleRuleSymbol(Kind = SimpleRuleKind.Token) when !this.Header.IsToken() =>
          def title = this.Header.Title();
          owner.Node.Project.Error(this, $"$title declaration is not allowed here.")

        | _ => ()
      }
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, this.Location);
      this.RuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context = RuleDeclarationSiteContext(parent, this.Symbol);
      _ = this.RuleAttributes.MakeContext(context);
      _ = MakePrecedenceRelations(this.RuleBody.MakeContext(PrecedenceZeroContext(PrecedenceStartContext(context, this.Symbol))));
      parent
    }
    [Cached]
    MakePrecedenceRelations(context : Context) : PrecedenceRelations * list[Precedence]
    {
      PrecedenceContext.MakePrecedenceRelations(context)
    }
    TypeSyntaxMappings() : void    = this.RuleBody.TypeSyntaxMappings();
    Typing() : void                = this.RuleBody.Typing();
  }

  syntax RuleBody
  {
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void = _ = owner;
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetLastLocation() : Nitra.Location;
    TypeSyntaxMappings() : void { }
    Typing() : void { }

    | Empty = ";"nl
      {
        override GetLastLocation = MakeLastLocation(this, Semicolon);
      }
    | Block = outline_begin_before nl "{" inl RuleBodyMember* d "}" outline_end_before nl
      {
        override CollectGlobalSymbols  { foreach (member in this.RuleBodyMembers) member.CollectGlobalSymbols(owner); }
        override MakeContext           = FoldThrough(this.RuleBodyMembers, parent, _.MakeContext(_));
        override GetLastLocation       = MakeLastLocation(this, OpenBrace);
        override TypeSyntaxMappings    = foreach (x in this.RuleBodyMembers) x.TypeSyntaxMappings();
        override Typing                = foreach (x in this.RuleBodyMembers) x.Typing();
      }
  }

  syntax PrecedenceReference2
  {
    GetBindingPowerInfo(context : Context, isStrong : bool) : BindingPowerInfo;

    | Zero = "0" as Zero
      {
        override GetBindingPowerInfo { _ = context; BindingPowerInfo(PrecedenceReference.Zero(), isStrong); }
      }
    | Identifier = Reference
      {
        override GetBindingPowerInfo = BindingPowerInfo(PrecedenceReference.Name(context.Bind.[PrecedenceSymbol](this.Reference)), isStrong);
      }
  }


  syntax PrecedenceName
  {
    MakeContext(parent : Context, owner : IPrecedenceSymbolOwner, symbol : PrecedenceSymbol, order : PrecedenceOrderList) : Context;
    GetName() : Nitra.Model.Identifier;

    | Zero = "0" as Zero
      {
        override MakeContext
        {
          _ = owner;
          _ = symbol;
          when (order is Some((errorLoc, _)))
            parent.Error(errorLoc, "Order not allowed for zero precedence.");
          PrecedenceZeroContext(parent)
        }
        override GetName = Nitra.Model.Identifier(Location(this.Location.Source, this.Zero), "0");
      }
    | Identifier=Name
      {
        override MakeContext
        {
          //TODO: добавить проверку порядка контекстов
          if (symbol != null)
            PrecedenceNamedContext(parent, owner, symbol, GetName(), order);
          else
            parent
        }
        override GetName = this.Name.Identifier();
      }
  }

  syntax RuleBodyMember
  {
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void = _ = owner;
    [Cached] MakeContext(parent : Context) : Context;
    TypeSyntaxMappings() : void { }
    Typing() : void { }

    | RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | RegexRule
      {
        override CollectGlobalSymbols = RegexRule.CollectGlobalSymbols(owner);
        override MakeContext          = RegexRule.MakeContext(parent);
        override TypeSyntaxMappings   = RegexRule.TypeSyntaxMappings();
        override Typing               = RegexRule.Typing();
      }
    | SimpleRule
      {
        override CollectGlobalSymbols = SimpleRule.CollectGlobalSymbols(owner);
        override MakeContext          = SimpleRule.MakeContext(parent);
        override TypeSyntaxMappings   = SimpleRule.TypeSyntaxMappings();
        override Typing               = SimpleRule.Typing();
      }
    | ExtensibleRule
      {
        override CollectGlobalSymbols = ExtensibleRule.CollectGlobalSymbols(owner);
        override MakeContext          = ExtensibleRule.MakeContext(parent);
        override TypeSyntaxMappings   = ExtensibleRule.TypeSyntaxMappings();
        override Typing               = ExtensibleRule.Typing();
      }
    | ExtensionRule = "|" sm RuleAttributes (Name "=")? RuleExpression RightAssociativeOpt=("right-associative")? RuleBody?
      {
        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedExtensionRuleSymbol = ParsedExtensionRuleSymbol(this, owner);
        override CollectGlobalSymbols
        {
          match (owner : object)
          {
            | ExtensibleRuleSymbol
            | ExtendSyntaxSymbol => ()
            | _ => owner.Node.Project.Error(this, "Extension rule declaration is not allowed here.")
          }
          def symbol = MakeSymbol(owner);
          _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
          when (RuleBodyOpt.HasValue)
            RuleBodyOpt.Value.CollectGlobalSymbols(symbol);
        }
        override MakeContext
        {
          def context = RuleDeclarationSiteContext(parent, Symbol);
          _ = RuleAttributes.MakeContext(context);
          _ = MakeRuleTypingContext(context);
          parent
        }
        [Cached] private MakeRuleTypingContext(parent : Context) : Context
        {
          if (RuleBodyOpt.HasValue)
            RuleBodyOpt.Value.MakeContext(parent)
          else
            parent
        }
        [Cached] private MakeBaseRuleRef() : ExtensibleRuleRef
        {
          match (this.Symbol.DeclarationSite)
          {
            | s is ExtensibleRuleSymbol => SymbolRef.Some(s.FirstLocation, false, s)
            | s is ExtendSyntaxSymbol   => s.Extend
            | owner                     => SymbolRef.None(owner.FirstLocation, false)
          }
        }
        [Cached] private MakeTypedRule(precedenceContext : PrecedenceContext) : Rule.Sequence = TypeRuleExpression(this.Symbol.Options, RuleTypingContext, RuleExpression.Typing(BaseRuleRef, PrecedenceInfo(precedenceContext, RightAssociativeOpt.HasValue, false), None(), RuleTypingContext, this.Symbol.Options));
        override TypeSyntaxMappings    = when (this.RuleBodyOpt.HasValue) this.RuleBodyOpt.Value.TypeSyntaxMappings();
        override Typing
        {
          def baseRule = MakeBaseRuleRef();
          _ = MakeTypedRule(RuleTypingContext.TryGetContext.[PrecedenceContext]());
          when (this.Symbol.Options.OperatorInfo == OperatorInfo.None && baseRule.IsSome)
            TryInferOperatorType(this.Symbol);
          when (this.RuleBodyOpt.HasValue)
            this.RuleBodyOpt.Value.Typing();
        }
      }
    | Precedence = "precedence" sm PrecedenceName Order=(sm "order" sm (Reference; sm "<" sm){2,})? ":"
      {
        [Cached] private MakeOwner(owner : IRuleDeclarationSite) : IPrecedenceSymbolOwner
        {
          match (owner)
          {
            | owner is IPrecedenceSymbolOwner => owner
            | _                               => owner.Node.Project.Error(this, "Precedence declaration is not allowed here."); null
          }
        }
        [Cached] private MakeSymbol() : PrecedenceSymbol
        {
          PrecedenceSymbol.GetPrecedenceSymbol(Owner, this.PrecedenceName.GetName())
        }
        override CollectGlobalSymbols
        {
          _ = MakeOwner(owner);
          _ = MakeSymbol();
        }
        override MakeContext
        {
          def order =
            if (Order.HasValue)
              Some(Order.Location, Order.Value.Item2.Item1.Identifiers())
            else
              None();

          PrecedenceName.MakeContext(parent, Owner, Symbol, order);
        }
        override Typing
        {
          when (Context is PrecedenceContext as context)
            context.Typing();
        }
      }
    | MapSyntax = "map" ParametersOpt=MapSyntaxParameters? sm AstName=NitraType MapSyntaxBody
      {
        [Cached] private MakeOwner(owner : IRuleDeclarationSite) : IRuleDeclarationSite = owner;
        override CollectGlobalSymbols { _ = MakeOwner(owner) }
        override MakeContext
        {
          def context = MapSyntaxContext(parent);
          _ = MapSyntaxBody.MakeContext(context);
          context
        }
        [Cached] private MakeParameters() : list[SyntaxMappingParameterSymbol] = if (this.ParametersOpt.HasValue) this.ParametersOpt.Value.Typing(this.Context) else [];
        [Cached] private MakeReturnType() : AstType = TypingUtils.NTypeToAstTypeWithMessage(this.AstName, this.Context);
        [Cached] private MakeSymbol() : SymbolRef[SyntaxMappingSymbol]
        {
          if (this.Owner : object is SyntaxRuleSymbol as ruleSymbol)
          {
            def symbol = ParsedInplaceSyntaxMappingSymbol(this, ruleSymbol);
            ruleSymbol.AddSyntaxMapping(symbol);
            SymbolRef.Some(this.Location, false, symbol)
          }
          else
          {
            this.Context.Error(this, "AST mapping is not allowed here.");
            SymbolRef.None(this.Location, false)
          }
        }
        [Cached] private MakeExpr() : SyntaxMappingExpr
        {
          if (this.Symbol is SymbolRef.Some(syntaxMapping))
            this.MapSyntaxBody.TypeSyntaxMappings(syntaxMapping, syntaxMapping.ReturnType)
          else
            null
        }
        override Typing
        {
          _ = MakeSymbol();
          (this.Context :> MapSyntaxContext).Initialize(MakeParameters(), MakeReturnType());
        }
        override TypeSyntaxMappings
        {
          _ = MakeExpr();
        }
      }
    | RuleMethod = RuleMethodAttributes RuleMethodPrivate? Name sm "(" (RuleMethodParam; "," sm)* ")" sm ":" sm Type=NitraType RuleMethodBody
      {
        token RuleMethodPrivate = "private" sm;

        override MakeContext = parent;
        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : RuleMethod.DefinitionSymbol
        {
          def compilerMessages = owner.Node.Project;
          match (owner)
          {
            | ruleSymbol is SyntaxRuleSymbol =>
              if (RuleMethodPrivateOpt.HasValue)
              {
                when (RuleMethodBody.IsEmpty())
                  compilerMessages.Error(this, "A private rule method must have a body.");
                unless (ruleSymbol is SimpleRuleSymbol || ruleSymbol is ExtensionRuleSymbol)
                  compilerMessages.Error(this, "A private rule method can be declared only in simple rules and extension rules.");
                RuleMethod.ParsedDefPrivateSymbol(this)
              }
              else if (RuleMethodBody.IsEmpty())
              {
                unless (ruleSymbol is ExtensibleRuleSymbol)
                  compilerMessages.Error(this, "An abstract rule method must be defined in an extension point rule only.");
                RuleMethod.ParsedAbstractSymbol(this)
              }
              else
              {
                unless (ruleSymbol is SimpleRuleSymbol || ruleSymbol is ExtensibleRuleSymbol)
                  compilerMessages.Error(this, "A public rule method must be defined in an extension point rule or a simple rule only.");
                RuleMethod.ParsedDefSymbol(this)
              }

            | _ => compilerMessages.Error(this, "Rule method is not allowed here."); null
          }
        }
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol(owner);
          when (symbol != null)
            _ = owner.Node.AddAndReport(symbol, this.Location);
        }
        [Cached] private MakeSignature() : RuleMethod.RuleMethodSignature
        {
          def context    = this.Context;
          def parameters = this.RuleMethodParams.Item1.MapToList(_.TypeForRuleMethod(context));
          def (type, _)  = this.Type.Typing(context);
          RuleMethod.RuleMethodSignature(this.Location, parameters, type);
        }
        [Cached] private MakeBody()     : RuleMethod.RuleMethodBody = this.RuleMethodBody.MakeBody(this.Context);
        [Cached] private MakeIsCached() : bool                      = RuleMethodAttributes.IsCached();
        [Cached] private MakeAstType()  : AstType                   = TypingUtils.NTypeToAstType(this.Signature.Type, this.Context);
        override Typing
        {
          when (this.Symbol != null)
          {
            _ = MakeSignature();
            _ = MakeBody();
            _ = MakeIsCached();
            _ = MakeAstType();
          }
        }
      }
    | RuleMethodOverride = RuleMethodAttributes "override"     sm  Name RuleMethodBody
      {
        override MakeContext = parent;
        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : RuleMethod.DefinitionSymbol
        {
          def compilerMessages = owner.Node.Project;
          match (owner)
          {
            | _ is SyntaxRuleSymbol =>
              when (RuleMethodBody.IsEmpty())
                compilerMessages.Error(this, "An overriding rule method must have a body.");
              RuleMethod.ParsedOverrideSymbol(this)

            | _ => compilerMessages.Error(this, "Rule method is not allowed here."); null
          }
        }
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol(owner);
          when (symbol != null)
            _ = owner.Node.AddAndReport(symbol, this.Location);
        }
        [Cached] private MakeBaseRuleMethod(compilerMessages : ICompilerMessages) : SymbolRef[RuleMethod.RuleMethodSymbol]
        {
          match (this.Symbol.DeclaringRule)
          {
            | ExtensionRuleSymbol(BaseRule = SymbolRef.Some(baseRuleSymbol)) =>
              match (baseRuleSymbol.Node.BindMany.[RuleMethod.DefinitionSymbol](Name.Location))
              {
                | [RuleMethod.DefSymbol      as baseRuleMethodSymbol]
                | [RuleMethod.AbstractSymbol as baseRuleMethodSymbol] =>
                  SymbolRef.Some(Name.Location, false, baseRuleMethodSymbol)

                | [_] =>
                  def name = Name.Value();
                  compilerMessages.Error(this, $"Cannot override '$name' rule method."); //TODO: rewrite error message!
                  SymbolRef.None(Name.Location, false)

                | _ =>
                  def name = Name.Value();
                  compilerMessages.Error(this, $"No '$name' rule method to override.");
                  SymbolRef.None(Name.Location, false)
              }

            | _ =>
              compilerMessages.Error(this, "An rule method can be overridden only in extending rules.");
              SymbolRef.None(Name.Location, false)
          }
        }
        [Cached] private MakeBody() : RuleMethod.RuleMethodBody = this.RuleMethodBody.MakeBody(this.Context);
        override Typing
        {
          when (this.Symbol != null)
          {
            _ = MakeBaseRuleMethod(this.Context);
            _ = MakeBody();
          }
        }
      }
    | RuleMethodMissing = RuleMethodAttributes "missing"        sm  Name RuleMethodBody
      {
        override MakeContext = parent;
        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : RuleMethod.RuleMethodMissingValueSymbol
        {
          def compilerMessages = owner.Node.Project;
          match (owner)
          {
            | _ is SyntaxRuleSymbol =>
              when (RuleMethodBody.IsEmpty())
                compilerMessages.Error(this, "A 'missing' handler must have a body.");
              RuleMethod.ParsedRuleMethodMissingValueSymbol(this);

            | _ => compilerMessages.Error(this, "Rule method is not allowed here."); null
          }
        }
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol(owner);
          when (symbol != null)
            _ = owner.Node.AddAndReport(symbol, this.Location);
        }
        [Cached] private MakeHandlingRuleMethod(compilerMessages : ICompilerMessages) : SymbolRef[RuleMethod.RuleMethodSymbol]
        {
          match (this.Symbol.DeclaringRule)
          {
            | ExtensibleRuleSymbol as targetRuleSymbol
            | SimpleRuleSymbol     as targetRuleSymbol =>
              match (targetRuleSymbol.Node.BindMany.[RuleMethod.DefinitionSymbol](Name.Location))
              {
                | [ruleMethodSymbol] => SymbolRef.Some(Name.Location, false, ruleMethodSymbol)
                | _ =>
                  def name = Name.Value();
                  compilerMessages.Error(this, $"No '$name' rule method to handle 'missing'.");
                  SymbolRef.None(Name.Location, false)
              }

            | _ =>
              compilerMessages.Error(this, "A 'missing' handler for a rule method can be defined in simple and extensible rules.");
              SymbolRef.None(Name.Location, false)
          }
        }
        [Cached] private MakeBody() : RuleMethod.RuleMethodBody = this.RuleMethodBody.MakeBody(this.Context);
        override Typing
        {
          when (this.Symbol != null)
          {
            _ = MakeHandlingRuleMethod(this.Context);
            _ = MakeBody();
          }
        }
      }
  }

  syntax RuleMethodParam = Name sm ":" sm Type=NitraType
  {
    TypeForRuleMethod(context : Context) : RuleMethod.RuleMethodParameter = RuleMethod.RuleMethodParameter(this.Location, this.Name.Identifier(), this.Type.Typing(context)[0]);
    TypeForMapSyntax(context : Context)  : SyntaxMappingParameterSymbol   = ChemicalSyntaxMappingParameterSymbol(this.Name.Identifier(), TypingUtils.NTypeToAstTypeWithMessage(this.Type, context));
  }

  syntax RuleMethodAttributes = RuleMethodAttributeList*
  {
    syntax RuleMethodAttribute
    {
      IsCached() : bool;

      | Cached = AttributeName="Cached" { override IsCached = true; }
    }

    syntax RuleMethodAttributeList = "[" (RuleMethodAttribute; ",")+ "]" nl
    {
      IsCached() : bool
      {
        foreach(x when x.IsCached() in RuleMethodAttributes.Item1)
          return true;
        false
      }
    }

    IsCached() : bool
    {
      foreach(x when x.IsCached() in RuleMethodAttributeLists)
        return true;
      false
    }
  }

  syntax RuleMethodBody
  {
    BodyLocation() : Nitra.Location;
    IsEmpty() : bool;
    MakeBody(context : Context) : RuleMethod.RuleMethodBody = RuleMethod.RuleMethodBody(this.BodyLocation(), NemerleParser.Parse(this, context));

    | Block
      {
        override BodyLocation = Block.Location;
        override IsEmpty = false;
      }
    | Expression = sm "=" sm Expression ";" nl
      {
        override BodyLocation = Expression.Location;
        override IsEmpty = false;
      }
    | Empty = ";" nl
      {
        override BodyLocation = this.Location.FromStart();
        override IsEmpty = true;
      }
  }

  syntax Block = outline_hiden outline_begin_before nl "{" inl (Expression; ";" nl)* ";"* nl d "}" outline_end_before nl;

  syntax ExpressionContent
  {
    | Block;
    | IgnoreToken+;
    | CharLiteral;
    | StringLiteral;
    | Parentheses = "(" Expression? ")";
    //| "fold" sm Identifier "(" Expression ";" (Expression; ";"sm)+ ")";
  }

  syntax Expression = Body=ContentOrText+
  {
    syntax ContentOrText
    {
      | ExpressionContent;
      | Text = (!";" !")" !"}" !ExpressionContent Any)+;
    }
  }

  syntax ArgumentExpression = Body=ContentOrText+
  {
    syntax ContentOrText
    {
      | ExpressionContent;
      | Text = (!";" !")" !"}" !"," !ExpressionContent Any)+;
    }
  }

  syntax Range
  {
    RangeSet(inCharSet : RangeSet, _compilationMessages : ICompilerMessages) : RangeSet;

    | SingleChar = CharLiteral
      {
        override RangeSet = inCharSet.AddSingleCharRange(CharLiteral.Value());
      }
    | CharRange       = CharLiteral ".." CharLiteral
      {
        override RangeSet = inCharSet.AddRange(CharLiteral1.Value(), CharLiteral2.Value());
      }
    | UnicodeRange    = Name
      {
        override RangeSet
        {
          def nameText = Name.Value();
          if (UnicodeCategoryTable.StrToUnicodeCategory(nameText) is Some(cat))
            inCharSet.AddRange(cat)
          else
          {
            _compilationMessages.Error(this, $"Invalid unicode category '$nameText'.");
            inCharSet
          }
        }
      }
  }

  syntax RepeatQuantifier
  {
    Bounds() : int * option[int];

    | ZeroOrMany = "*"                                { override Bounds = (0,               None());                }
    | OneOrMany  = "+"                                { override Bounds = (1,               None());                }
    | UpperBound = "{" sm        "," sm Number sm "}" { override Bounds = (0,               Some(Number.Value()));  }
    | LowerBound = "{" sm Number ","           sm "}" { override Bounds = (Number.Value(),  None());                }
    | FullBounds = "{" sm Number "," sm Number sm "}" { override Bounds = (Number1.Value(), Some(Number2.Value())); }
    | Exact      = "{" sm Number               sm "}" { override Bounds { def x = Number.Value(); (x, Some(x)); }   }
  }

  alias Separator  = RegexExpression;

  syntax RegexExpression
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    [Cached] Typing() : RegularRule;

    precedence Choice:
    | Choice                  = LeftRule=RegexExpression ^ Choice sm RightRules=("|" RegexExpression ^ Choice)+
      {
        override MakeContext
        {
          def context1 = LeftRule.MakeContext(parent);
          def context2 = FoldThrough(RightRules, context1, (t, c) => t.Item2.MakeContext(c));
          context2
        }
        override Typing = RegularRule.Choice(Location, LeftRule.Typing() :: RightRules.Map(r => r.Item2.Typing()));
      }

    precedence Sequence:
    | Sequence                = LeftRule=RegexExpression ^ Sequence sm RightRules=(RegexExpression ^ Sequence)+
      {
        override MakeContext
        {
          def context1 = LeftRule.MakeContext(parent);
          def context2 = FoldThrough(RightRules, context1, _.MakeContext(_));
          context2
        }
        override Typing = RegularRule.Sequence(Location, LeftRule.Typing() :: RightRules.Map(_.Typing()));
      }

    precedence Subtract:
    | Subtract                = Rule1 = RegexExpression "-" Rule2 = RegexExpression
      {
        override MakeContext = Rule2.MakeContext(Rule1.MakeContext(parent));
        override Typing = RegularRule.Subtract(Location, this.Rule1.Typing(), this.Rule2.Typing());
      }

    precedence Invert:
    | Invert                  = "~" RegexExpression
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing = RegularRule.Invert(Location, this.RegexExpression.Typing());
      }

    precedence RepeatModifier:
    | Optional                = RegexExpression "?"
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing = RegularRule.Repeat(Location, 0, Some(1), this.RegexExpression.Typing());
      }
    | Repeat              = RegexExpression RepeatQuantifier
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing
        {
          def (lower, upper) = RepeatQuantifier.Bounds();
          RegularRule.Repeat(Location, lower, upper, this.RegexExpression.Typing());
        }
      }

    precedence 0:
    | Char                    = CharLiteral
      {
        override Typing = RegularRule.Chars(Location, [RangeSet().AddSingleCharRange(CharLiteral.Value())]);
      }
    | String                  = StringLiteral
      {
        override Typing = RegularRule.Chars(Location, RangeSet.MakeString(StringLiteral.Value()));
      }
    | Call                    = QualifiedReference
      {
        override Typing = RegularRule.Call(Location, this.Context.Bind.[RegularRuleSymbol](QualifiedReference));
      }
    | Rounds                  = "(" RegexExpression ")"
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing = RegexExpression.Typing();
      }
    | Range                   = "[" (Range; ","sm)+ "]"
      {
        override Typing
        {
          def compilerMessages = this.Context;
          RegularRule.Chars(Location, [FoldThrough(Ranges.Item1, RangeSet(), _.RangeSet(_, compilerMessages))]);
        }
      }
    | InvertedRange           = "[" "^" (Range; ","sm)+ "]"
      {
        override Typing
        {
          def compilerMessages = this.Context;
          RegularRule.Chars(Location, InvertRange(FoldThrough(Ranges.Item1, RangeSet(), _.RangeSet(_, compilerMessages))));
        }
      }
    | RepeatWithSeparator = "(" RegexExpression ";"sm Separator ")" RepeatQuantifier
      {
        override MakeContext  = parent |> RegexExpression.MakeContext |> Separator.MakeContext;
        override Typing
        {
          def (lower, upper) = RepeatQuantifier.Bounds();
          RegularRule.RepeatWithSeparator(Location, lower, upper, RegexExpression.Typing(), Separator.Typing());
        }
      }
  }

  alias Separator   = RuleExpression;

  syntax RuleExpression
  {
    Typing(_baseRule : option[ExtensibleRuleSymbol], _precedenceInfo : PrecedenceInfo, _fieldName : option[string], context : Context, _options : RuleDefinitionOptions) : Nitra.Model.Rule;
    InferName() : string = "";

    precedence Sequence:
    | Sequence                        = LeftRule=RuleExpression ^ Sequence RightRules=(sm RuleExpression ^ Sequence)+
      {
        override Typing = TypeSequence(_baseRule, _precedenceInfo, _fieldName, context, _options, LeftRule, RightRules, this);
        override InferName = LeftRule.InferName();
      }

    precedence FieldName2:
    | FieldName2                      = Name=Text sm "=" sm RuleExpression ^ FieldName2
      {
        override Typing = RuleExpression.Typing(_baseRule, _precedenceInfo, Some(Name.Value()), context, _options);
        override InferName = Name.GetText();
      }

    precedence FieldName1:
    | FieldName1                      = RuleExpression ^ FieldName1 sm "as" sm Name=Text
      {
        override Typing = RuleExpression.Typing(_baseRule, _precedenceInfo, Some(Name.Value()), context, _options);
        override InferName = Name.GetText();
      }

    precedence Predicate:
    | Not                             = "!" RuleExpression ^ Predicate
      {
        override Typing
        {
          def rule = this.RuleExpression.Typing(None(), _precedenceInfo, None(), context, _options);
          Rule.Not(this.Location, RuleType.Void(), "", rule);
        }
      }
    | And                             = "&" RuleExpression ^ Predicate
      {
        override Typing = Rule.And(this.Location, RuleType.Void(), "", RuleExpression.Typing(None(), _precedenceInfo, None(), context, _options));
      }

    precedence RepeatModifier:
    | Optional                        = RuleExpression "?"
      {
        override Typing
        {
          def rule  = RuleExpression.Typing(None(), _precedenceInfo, None(), context, _options);
          def type  = EvaluateOptionRuleType(rule);
          Rule.Repeat(this.Location, type, _fieldName ?? (rule.FieldName + "Opt"), 0, Some(1), rule);
        }
        override InferName = RuleExpression.InferName() + "Opt";
      }
    | Repeat                      = RuleExpression RepeatQuantifier
      {
        override Typing
        {
          def rule           = RuleExpression.Typing(None(), _precedenceInfo, None(), context, _options);
          def type           = EvaluateListRuleType(rule);
          def (lower, upper) = RepeatQuantifier.Bounds();
          Rule.Repeat(this.Location, type, MakePlural(_fieldName, rule, context), lower, upper, rule);
        }
        override InferName = MakePlural(RuleExpression.InferName());
      }

    precedence 0:
    | Char                            = CharLiteral
      {
        override Typing = StringRuleTyping(CharLiteral.Location, CharLiteral.Value().ToString(), _fieldName, context);
        override InferName = CharLiteral.Value().ToString();
      }
    | String                          = StringLiteral
      {
        override Typing = StringRuleTyping(StringLiteral.Location, StringLiteral.Value().ToString(), _fieldName, context);
        override InferName = StringLiteral.Value().ToString();
      }
    | Rounds                          = "(" RuleExpression ")"
      {
        override Typing = RuleExpression.Typing(_baseRule, _precedenceInfo, _fieldName, context, _options);
        override InferName = RuleExpression.InferName();
      }
    | Call                            = QualifiedReference BindingPower=(sm "^" sm "+"? PrecedenceReference2)?
      {
        override Typing = TypeCall(_baseRule, _precedenceInfo, _fieldName, context, _options, QualifiedReference, BindingPower);
        override InferName = QualifiedReference.LastIdentifier().Value;
      }
    | RepeatWithSeparator         = "(" RuleExpression ";"sm Separator HangingOpt=(";"sm "?")? ")" RepeatQuantifier
      {
        override Typing
        {
          def rule           = RuleExpression.Typing(None(), _precedenceInfo, None(), context, _options);
          def sepRule        = Separator.Typing(None(), PrecedenceInfo.None, None(), context, _options);
          def type           = EvaluateListWithSeparatorRuleType(rule, sepRule);
          def (lower, upper) = RepeatQuantifier.Bounds();
          def isHanging      = HangingOpt.HasValue;
          Rule.RepeatWithSeparator(this.Location, type, MakePlural(_fieldName, rule, sepRule, context), lower, upper, rule, sepRule, isHanging);
        }
        override InferName = MakePlural(RuleExpression.InferName());
      }
  } // extend syntax RuleExpression
} // syntax module
