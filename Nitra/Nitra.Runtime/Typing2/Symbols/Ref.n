using Nitra;
using Nitra.Declarations;
using Nitra.ProjectSystem;
using Nitra.Internal;
using Nitra.Serialization2;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Runtime.Binding
{
  public interface IRef : ILocated, ISerializable
  {
    Name        : string    { get; }
    IsNameValid : bool      { get; }

    [DependentProperty("IsFullNameEvaluated")]
    FullName            : string { get; }
    IsFullNameEvaluated : bool   { get; }

    [DependentProperty("IsKindEvaluated")]
    Kind            : string { get; }
    IsKindEvaluated : bool   { get; }

    [DependentProperty("IsSpanClassEvaluated")]
    SpanClass            : SpanClass { get; }
    IsSpanClassEvaluated : bool      { get; }

    [DependentProperty("IsSymbolEvaluated")]
    Symbol            : ISymbol2 { get; }
    IsSymbolEvaluated : bool     { get; }

    [DependentProperty("IsScopeEvaluated")]
    Scope             : Scope    { get; }
    IsScopeEvaluated  : bool     { get; }

    TryResolve[TConcreteSymbol](algorithm : ResolutionAlgorithm[ISymbol2, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
      where TConcreteSymbol : ISymbol2;
    Resolve[TConcreteSymbol](algorithm : ResolutionAlgorithm[ISymbol2, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
      where TConcreteSymbol : ISymbol2;
    GetSymbols() : Seq[ISymbol2];
  }

  [Record]
  public variant Ref[TSymbol] : IRef
    where TSymbol : ISymbol2
  {
    public          File        : Nitra.ProjectSystem.File { get; }
    public          Span        : NSpan     { get; }
    public abstract Name        : string    { get; }
    public abstract IsNameValid : bool      { get; }

    [DependentProperty("IsFullNameEvaluated")]
    public abstract FullName            : string { get; }
    public abstract IsFullNameEvaluated : bool   { get; }

    [DependentProperty("IsKindEvaluated")]
    public abstract Kind            : string { get; }
    public abstract IsKindEvaluated : bool   { get; }

    [DependentProperty("IsSpanClassEvaluated")]
    public abstract SpanClass            : SpanClass { get; }
    public abstract IsSpanClassEvaluated : bool      { get; }

    [DependentProperty("IsSymbolEvaluated")]
    public abstract Symbol            : TSymbol { get; }
    public abstract IsSymbolEvaluated : bool    { get; }

    public IsAllPropertiesEvaluated : bool  { get { true } }
    public PropertiesEvalState      : int   { get { 0 } }

    [DependentProperty("IsScopeEvaluated")]
    public Scope : Scope
    {
      get { if (IsSymbolEvaluated) Symbol.Scope else EmptyScope.Instance }
    }

    public IsScopeEvaluated : bool
    {
      get { if (IsSymbolEvaluated) Symbol.IsScopeEvaluated else true }
    }

    TryResolveImpl[TConcreteSymbol](algorithm : ResolutionAlgorithm[ISymbol2, TConcreteSymbol]) : Ref[TConcreteSymbol]
      where TConcreteSymbol : ISymbol2
      implements IRef.TryResolve
    {
      // type cast avoids invalid IL
      TryResolve((algorithm : object) :> ResolutionAlgorithm[TSymbol, TConcreteSymbol])
    }

    ResolveImpl[TConcreteSymbol](algorithm : ResolutionAlgorithm[ISymbol2, TConcreteSymbol]) : Ref[TConcreteSymbol]
      where TConcreteSymbol : ISymbol2
      implements IRef.Resolve
    {
      // type cast avoids invalid IL
      Resolve((algorithm : object) :> ResolutionAlgorithm[TSymbol, TConcreteSymbol])
    }

    public abstract TryResolve[TConcreteSymbol](algorithm : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
      where TConcreteSymbol : ISymbol2;

    public Resolve[TConcreteSymbol](algorithm : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
      where TConcreteSymbol : ISymbol2
    {
      def r = TryResolve(algorithm);
      SymbolUtils.ReportError(r);
      r
    }

    public override ToString() : string { Name + " (" + Kind + ")" }
    public abstract GetSymbols() : Seq[ISymbol2];
    public abstract Serialize(writer : BinaryWriter, metadataWriter : MetadataWriter) : void;

    | Some
      {
        public override Name        : string    { get { Symbol.Name } }
        public override IsNameValid : bool      { get { Symbol.IsNameValid } }

        [DependentProperty("IsFullNameEvaluated")]
        public override FullName            : string { get { Symbol.FullName } }
        public override IsFullNameEvaluated : bool   { get { Symbol.IsFullNameEvaluated } }
  
        [DependentProperty("IsKindEvaluated")]
        public override Kind            : string { get { Symbol.Kind } }
        public override IsKindEvaluated : bool   { get { Symbol.IsKindEvaluated } }
  
        [DependentProperty("IsSpanClassEvaluated")]
        public override SpanClass            : SpanClass { get { Symbol.SpanClass } }
        public override IsSpanClassEvaluated : bool      { get { Symbol.IsSpanClassEvaluated } }

        [DependentProperty("IsSymbolEvaluated")]
        public override Symbol            : TSymbol { get; }
        public override IsSymbolEvaluated : bool    { get { true } }

        public override TryResolve[TConcreteSymbol](algorithm : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
        {
          def algorithm = algorithm ?? ResolutionAlgorithms.TryCast;

          match (algorithm(Symbol))
          {
            | VSome(symbol) => Ref.Some(File, Span, symbol)
            | VNone         => Ref.Unresolved(File, Span, Name, ResolutionSource.Resolve(this))
          }
        }

        public override GetSymbols() : Seq[ISymbol2]
        {
          // type hint avoids invalid IL
          array[Symbol : ISymbol2]
        }
        public override GetHashCode() : int { Symbol.GetHashCode() }
        public override Equals(other : object) : bool
        {
          | other is Some => this.Symbol.Equals(other.Symbol)
          | _ => false
        }

        public override Serialize(writer : BinaryWriter, metadataWriter : MetadataWriter) : void
        {
          metadataWriter.WriteObject(File, writer);
          metadataWriter.WriteObject(Symbol, writer);
        }

        public static Deserialize(reader : BinaryReader, metadataReader : MetadataReader) : this
        {
          def file   = metadataReader.ReadObject(reader);
          def symbol = metadataReader.ReadObject(reader);
          Ref.Some(file, NSpan(), symbol)
        }
      }

    | Unresolved
      {
        public override Name        : string           { get; }
        public          Source      : ResolutionSource { get; }
        public override IsNameValid : bool             { get { true } }

        [DependentProperty("IsFullNameEvaluated")]
        public override FullName            : string { get { Name } }
        public override IsFullNameEvaluated : bool   { get { true } }
  
        [DependentProperty("IsKindEvaluated")]
        public override Kind            : string { get { "unresolved" } }
        public override IsKindEvaluated : bool   { get { true } }
  
        [DependentProperty("IsSpanClassEvaluated")]
        public override SpanClass            : SpanClass { get { Language.ErrorSpanClass } }
        public override IsSpanClassEvaluated : bool      { get { true } }

        [DependentProperty("IsSymbolEvaluated")]
        public override Symbol            : TSymbol { get { assert(false, "Ref is unresolved.") } }
        public override IsSymbolEvaluated : bool    { get { false } }

        public override TryResolve[TConcreteSymbol](algorithm : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
        {
          _ = algorithm;
          Ref.Unresolved(File, Span, Name, ResolutionSource.Resolve(this))
        }

        public override GetSymbols() : Seq[ISymbol2] { Enumerable.Empty() }
        public override GetHashCode() : int { Name.GetHashCode() }
        public override Equals(other : object) : bool
        {
          | other is Unresolved => EqualityComparer.Default.Equals(this.File, other.File) && this.Span.Equals(other.Span) && StringComparer.Ordinal.Equals(this.Name, other.Name)
          | _ => false
        }

        public override Serialize(writer : BinaryWriter, metadataWriter : MetadataWriter) : void
        {
          metadataWriter.WriteObject(File, writer);
          writer.Write(Name : string);
        }

        public static Deserialize(reader : BinaryReader, metadataReader : MetadataReader) : this
        {
          def file = metadataReader.ReadObject(reader);
          def name = reader.ReadString();
          Ref.Unresolved(file, NSpan(), name, null)
        }
      }

    | Ambiguous
      {
        public          Ambiguities : list[TSymbol]    { get; }
        public          Source      : ResolutionSource { get; }

        public override Name        : string    { get { Ambiguities.Head.Name } }
        public override IsNameValid : bool      { get { Ambiguities.Head.IsNameValid } }

        [DependentProperty("IsFullNameEvaluated")]
        public override FullName            : string { get { Ambiguities.Head.FullName } }
        public override IsFullNameEvaluated : bool   { get { Ambiguities.Head.IsFullNameEvaluated } }
  
        [DependentProperty("IsKindEvaluated")]
        public override Kind            : string { get { "ambiguous" } }
        public override IsKindEvaluated : bool   { get { true } }
  
        [DependentProperty("IsSpanClassEvaluated")]
        public override SpanClass            : SpanClass { get { Language.ErrorSpanClass } }
        public override IsSpanClassEvaluated : bool      { get { true } }

        [DependentProperty("IsSymbolEvaluated")]
        public override Symbol            : TSymbol          { get { assert(false, "Ref is ambiguous.") } }
        public override IsSymbolEvaluated : bool             { get { false } }
        public          AllDeclarations   : Seq[Declaration] { get { Ambiguities.SelectMany(_.Declarations) } }

        public override TryResolve[TConcreteSymbol](algorithm : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
        {
          def algorithm = algorithm ?? ResolutionAlgorithms.TryCast;

          def results = LightList.[TConcreteSymbol]();
          foreach (s in Ambiguities)
            when (algorithm(s) is VSome(symbol))
              results.Add(symbol);

          match (results.Count)
          {
            | 0 => Ref.Unresolved(File, Span, Name, ResolutionSource.Resolve(this))
            | 1 => Ref.Some(File, Span, results.FirstItem)
            | _ => Ref.Ambiguous(File, Span, results.ToNList(), ResolutionSource.Resolve(this))
          }
        }

        public override GetSymbols() : Seq[ISymbol2]
        {
          // cast avoids invalid IL
          (Ambiguities : object) :> Seq[ISymbol2]
        }
        public override ToString() : string { $<#$Kind: ..$(Ambiguities; " "; _.FullName)#> }
        public override GetHashCode() : int { Ambiguities.GetHashCode() }
        public override Equals(other : object) : bool
        {
          | other is Ambiguous => this.Ambiguities.Equals(other.Ambiguities)
          | _ => false
        }

        public override Serialize(writer : BinaryWriter, metadataWriter : MetadataWriter) : void
        {
          metadataWriter.WriteObject(File, writer);
          metadataWriter.WriteObjects(Ambiguities, writer);
        }

        public static Deserialize(reader : BinaryReader, metadataReader : MetadataReader) : this
        {
          def file    = metadataReader.ReadObject(reader);
          def symbols = metadataReader.ReadObjects(reader);
          Ref.Ambiguous(file, NSpan(), symbols.ToNList(), null);
        }
      }
  }
}
