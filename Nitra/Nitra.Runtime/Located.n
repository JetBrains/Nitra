using System;
using System.Runtime;
using System.Runtime.ConstrainedExecution;
using System.Text.RegularExpressions;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Utility;
using Nemerle.Text;

using SCG = System.Collections.Generic;

namespace Nitra
{
  public abstract class Located
  {
    public static @:(located : Located) : Location
    {
      located.Location
    }

    public abstract Location : Location { get; }

    public GetText() : string { Location.GetText() }

    public GetText(token : NSpan) : string
    {
      Location.Source.Text.Substring(token.StartPos, token.EndPos - token.StartPos)
    }

    public FirstChar(token : NSpan) : char
    {
      Location.Source.Text[token.StartPos]
    }

    [TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    public IntersectsWith(start : int, end : int) : bool { this.Location.IntersectsWith(start, end) }
    [TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    public IntersectsWith(other : NSpan)         : bool { this.Location.IntersectsWith(other) }
    [TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    public Intersection(start : int, end : int)   : ValueOption[Location]
    {
      this.Location.Intersection(start, end)
    }
  }
}
