using Nitra.Runtime.Binding;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CSharp
{
  public partial class UsingAliasDirectiveSymbol : DeclaredSymbol
  {
    public override Kind             : string             { get { "namespace" } }
    public override SpanClass        : string             { get { "NitraCSharpNamespace" } }
    
    public override Scope            : Scope               { get { ReplacementSymbol.Scope } }
  }
  
  public partial interface NamespaceMemberSymbol : ISymbol2
  {
  }

  public partial class NamespaceSymbol : DeclaredSymbol, NamespaceMemberSymbol
  {
    public override Scope       : Scope           { get { MemberScope } }

    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(0, candidate) }
    public override CanMerge(candidate : Declaration) : bool { candidate is Namespace }
    public override Kind             : string             { get { "namespace" } }
    public override SpanClass        : string             { get { "NitraCSharpNamespace" } }
  }

  public partial interface TypeMemberSymbol : ISymbol2
  {
  }

  public partial interface TypeSymbol : ISymbol2
  {
  }

  public partial interface GenericTypeSymbol : TypeSymbol
  {
  }

  public partial interface EnumSymbol : TypeSymbol
  {
  }

  public partial class TopEnumSymbol : DeclaredSymbol, EnumSymbol, NamespaceMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(0, candidate) }
    public override CanMerge(candidate : Declaration) : bool { candidate is TopEnum }
    public override Kind             : string             { get { "enum" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class NestedEnumSymbol : DeclaredSymbol, EnumSymbol, TypeMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(0, candidate) }
    public override CanMerge(candidate : Declaration) : bool { candidate is NestedEnum }
    public override Kind             : string             { get { "enum" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial interface DelegateSymbol : GenericTypeSymbol
  {
  }

  public partial class TopDelegateSymbol : DeclaredSymbol, DelegateSymbol, NamespaceMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.TopDelegate](TypeParametersCount, candidate) }
    public override Kind             : string             { get { "declared" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class NestedDelegateSymbol : DeclaredSymbol, DelegateSymbol, TypeMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.NestedDelegate](TypeParametersCount, candidate) }
    public override Kind             : string             { get { "declared" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial interface GenericContainerTypeSymbol : GenericTypeSymbol
  {
  }

  public partial class TopClassSymbol : DeclaredSymbol, GenericContainerTypeSymbol, NamespaceMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.TopClass](this, candidate) }
    public override Kind             : string             { get { "class" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class NestedClassSymbol : DeclaredSymbol, GenericContainerTypeSymbol, TypeMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.NestedClass](this, candidate) }
    public override Kind             : string             { get { "class" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class TopStructSymbol : DeclaredSymbol, GenericContainerTypeSymbol, NamespaceMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.TopStruct](this, candidate) }
    public override Kind             : string             { get { "struct" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class NestedStructSymbol : DeclaredSymbol, GenericContainerTypeSymbol, TypeMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.NestedStruct](this, candidate) }
    public override Kind             : string             { get { "struct" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class TopInterfaceSymbol : DeclaredSymbol, GenericContainerTypeSymbol, NamespaceMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.TopInterface](this, candidate) }
    public override Kind             : string             { get { "interface" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }
  
  public partial class NestedInterfaceSymbol : DeclaredSymbol, GenericContainerTypeSymbol, TypeMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.NestedInterface](this, candidate) }
    public override Kind             : string             { get { "interface" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial interface MemberSymbol : ISymbol2, TypeMemberSymbol
  {
  }

  public partial class TypeParameterSymbol : DeclaredSymbol
  {
    public override Kind             : string             { get { "type parameter" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
    
    private mutable _aliases : list[TypeParameterAlias] = [];
    
    public Aliases : list[TypeParameterAlias] { get { _aliases } }
    
    internal AddAliasSymbol(alias : TypeParameterAlias) : void
    {
      _aliases ::= alias;
      def decl = TypeParameter(alias.File, alias.Span, alias.Name, false);
      AddDeclaration(decl);
    }
  }

  public partial class TypeParameterAliasSymbol : DeclaredSymbol
  {
    public override Kind             : string              { get { "type parameter alias" } }
    public override SpanClass        : string              { get { "NitraCSharpAlias" } }
    public override ResolutionResult : ISymbol2            { get { TypeParameter } }
  }

  module SymbolUtils
  {
    public IsPartial(symbol : GenericContainerTypeSymbol) : bool
    {
      symbol.Declarations.First().IsPartial.ValueOrDefault
    }

    public IsSameIdentity(typeParametersCount : int, candidate : Declaration) : bool
    {
      match (candidate)
      {
        | CSharp.GenericType as t => t.TypeParameterAliases.Count == typeParametersCount
        | CSharp.Namespace
        | CSharp.Type             => typeParametersCount == 0
        | _                       => false
      }
    }

    public CanMerge[T](typeParametersCount : int, candidate : Declaration) : bool
      where T : GenericType
    {
      match (candidate)
      {
        | genericType is T => genericType.TypeParameterAliases.Count == typeParametersCount
        | _ => false
      }
    }

    public CanMerge[T](symbol : GenericContainerTypeSymbol, candidate : Declaration) : bool
      where T : GenericContainerType
    {
      match (candidate)
      {
        | genericType is T => genericType.TypeParameterAliases.Count == symbol.TypeParametersCount && symbol.IsPartial && genericType.IsPartial.ValueOrDefault
        | _ => false
      }
    }
  }
}
