using Nitra;
using Nitra.Declarations;
using Nitra.Runtime.Binding;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
// TODO: rename Symbol2 to Symbol and remove follow line
using Symbol  = Nitra.Runtime.Binding.Symbol2;
using ISymbol = Nitra.Runtime.Binding.ISymbol2;

namespace CSharp
{
  module Utils
  {
    public MakeMembersScope(currentScope : Scope, opening : list[Scope], aliases : TableScope) : Scope
    {
      def makeCurrentScope(scope : Scope) : Scope
      {
        def withAliases =
          if (aliases.Symbols.Count == 0)
            scope
          else
            UnionScope([scope, aliases]);

        def withUsings =
          match (opening)
          {
            | []    => withAliases
            | [one] => HidingScope(withAliases, one)
            | _     => HidingScope(withAliases, UnionScope(opening))
          };

        withUsings
      }

      if (currentScope is HidingScope as h)
        HidingScope(makeCurrentScope(h.Scope), h.Hidden)
      else
        makeCurrentScope(currentScope)
    }

    public MakeEnteredScope(parentScope : Scope, parentNs : NamespaceSymbol, enteredNs : NamespaceSymbol) : Scope
    {
      def buildEnterNsScope(ns : NamespaceSymbol) : Scope
      {
        def parent = ns.Parent;
        def scope  = ns.Scope;
        
        if (parent : object == parentNs)
          HidingScope(scope, parentScope)
        else
          HidingScope(scope, buildEnterNsScope(parent))
      }
      
      buildEnterNsScope(enteredNs)
    }

    [Memoize]
    public TypeOverloadResolution(argumentsCount : int) : ResolutionAlgorithm[ISymbol2, ISymbol2]
    {
      def resolve(candidate : ISymbol2) : ValueOption[ISymbol2]
      {
        | symbol is UsingAliasDirectiveSymbol when argumentsCount == 0                          => VSome(symbol)
        | symbol is TypeParameterAliasSymbol  when symbol.IsTypeParameterEvaluated              => resolve(symbol.TypeParameter)
        | symbol is TypeParameterSymbol       when argumentsCount == 0                          => VSome(symbol)
        | symbol is NamespaceSymbol           when argumentsCount == 0                          => VSome(symbol)
        | symbol is GenericTypeSymbol         when argumentsCount == symbol.TypeParametersCount => VSome(symbol)
        | _ => VNone()
      }
      resolve
    }

    private _noTypeParameters : array[TypeParameterSymbol] = array(0);

    public CreateTypeParameters(count : int) : array[TypeParameterSymbol]
    {
      if (count == 0)
        _noTypeParameters
      else
      {
        def result = array(count);
        for (mutable i = 0; i < result.Length; ++i)
          result[i] = TypeParameterSymbol();
        result
      }
    }

    public GetTypeParametersCount(declarations : Seq[GenericType]) : int
    {
      declarations.First().TypeParameterAliases.Count
    }

    public GetTypeParameter(alias : TypeParameterAlias, typeParameterSymbols : IList[TypeParameterSymbol], IndexIn : int) : TypeParameterSymbol
    {
      def typeParameterSymbol = typeParameterSymbols[IndexIn];
      typeParameterSymbol.AddAliasSymbol(alias);
      typeParameterSymbol
    }
  }
}
