using DotNet;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using Nitra.Declarations;
using Nitra.ProjectSystem;

using Microsoft.Cci;

using System;
using System.IO;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;

using NRB = Nitra.Declarations;

namespace Nitra.BackEnd.Cci
{
  [Record]
  public class CciBackEnd : IBackEnd
  {
    public static NoLoc : Location = Location(SourceSnapshot.Default.File, NSpan(0));
    public CciHost : IMetadataHost { get; protected set; }
    
    public this() { this(PeReader.DefaultHost()) }
    
    public LoadExternalSymbols(project : Project, context : DependentPropertyEvalContext) : NamespaceSymbol
    {
      Debug.WriteLine("LoadExternalSymbols started");
      
      def timer = Stopwatch.StartNew();
      def cciInternedKeyToSymbolMap = Hashtable.[uint, TypeSymbol]();
      def noLoc  = NoLoc;
      def noFile = noLoc.Source.File;
      def noSpan = noLoc.Span;
      def rootNamespace = NamespaceSymbol();
      rootNamespace.MemberTable = TableScope("<root namespace>", rootNamespace);
      rootNamespace.DeclaredIn  = null;
      rootNamespace.FullName    = "";
      rootNamespace.EvalProperties(context);
      def libs = project.Libs;
      def createTypeParameters(cciType : ITypeDefinition) : array[TypeParameterSymbol]
      {
        def count = cciType.GenericParameterCount : int;
        if (count == 0)
          AstUtils.NoTypeParameters
        else
        {
          def result = array(count);
          foreach (tp in cciType.GenericParameters with i)
          {
            def name  = NRB.Name(noFile, noSpan, tp.Name.Value); // TODO: type.Name.UniqueKey
            def tps   = TypeParameterDeclaration(name, tp).DefineSymbol();
            tps.EvalProperties(context);
            result[i] = tps;
          }
          result
        }
      }
      def makeTypeParameters(symbol : GenericTypeSymbol, cciType : ITypeDefinition) : void
      {
        unless (symbol.IsTypeParametersCountEvaluated)
          symbol.TypeParametersCount = cciType.GenericParameterCount;
        unless (symbol.IsTypeParametersEvaluated)
          symbol.TypeParameters = createTypeParameters(cciType);
      }
      
      def host = CciHost;
      
      foreach(lib in libs)
      {
        | name is FullNameLibReference with filePath = name.Path
        | file is FileLibReference     with filePath = file.Path =>
          def fullPath = Path.GetFullPath(IO.Path.Combine(project.ProjectDir, filePath));
            
          when (!File.Exists(fullPath))
          {
            project.CompilerMessages.Error(noLoc, "The referenced file '" + fullPath + "' is not found.");
            continue;
          }
            
          def unit = host.LoadUnitFrom(fullPath) :> IAssembly;
          
          when (unit == null || unit.Equals(Dummy.Module) || unit.Equals(Dummy.Assembly))
          {
            project.CompilerMessages.Error(noLoc, "The referenced file '" + fullPath + "' is not .Net assembly.");
            continue;
          }

          def initTypeSymbol(typeSymbol : DeclaredTypeSymbol, type : ITypeDefinition) : void
          {
            cciInternedKeyToSymbolMap[type.InternedKey] = typeSymbol;
                
            when (typeSymbol is GenericTypeSymbol as genericSymbol)
              makeTypeParameters(genericSymbol, type);
            
            def modifierHost = typeSymbol;
            def flags = ModifierSet(context);
            mutable modifiers;
            when (type.IsAbstract)
              modifiers |= Modifiers.Abstract;
            when (type.IsSealed)
              modifiers |= Modifiers.Sealed;
            when (type.IsStatic)
              modifiers |= Modifiers.Static;

            // Modifiers
            match (type)
            {
              | INamespaceTypeDefinition as nsType => 
                when (nsType.IsPublic)
                  modifiers |= Modifiers.Public;
                  
              | INestedTypeDefinition as nsType =>
                when (nsType.Visibility == TypeMemberVisibility.Private)
                  modifiers |= Modifiers.Private;
                when (nsType.Visibility == TypeMemberVisibility.Public)
                  modifiers |= Modifiers.Public;
                when (nsType.Visibility == TypeMemberVisibility.FamilyOrAssembly)
                  modifiers |= (Modifiers.Protected | Modifiers.Internal);
                when (nsType.Visibility == TypeMemberVisibility.Family)
                  modifiers |= Modifiers.Protected;
            }
                
            flags.Add(modifiers);
            modifierHost.Flags = flags;

            typeSymbol.EvalProperties(context);
                
            when ((typeSymbol : DeclarationSymbol) is ContainerSymbol as containerSymbol)
            {
              unless (containerSymbol.IsScopeEvaluated)
                typeSymbol.Scope = containerSymbol.MemberTable;
            }

            when (typeSymbol is GenericContainerTypeSymbol as genericContainerTypeSymbol)
            {
              def nestedTypes = LightList();
              foreach (cciNestedType in type.NestedTypes)
              {
                def visibility = cciNestedType.Visibility;
                when (visibility != TypeMemberVisibility.Private && visibility != TypeMemberVisibility.Assembly)
                  nestedTypes.Add(loadNestedType(cciNestedType, genericContainerTypeSymbol));
              }
            }
          }
          and loadNestedType(type : INestedTypeDefinition, declaredIn : GenericContainerTypeSymbol) : NestedTypeSymbol
          {
            def name = Name(noFile, noSpan, type.Name.Value); // TODO: type.Name.UniqueKey
            def symbol : NestedTypeSymbol  =
                     if (type.IsDelegate)  ExternalNestsdTypeDeclaration.[NestedDelegateSymbol] (name, type).DefineSymbol(declaredIn.MemberTable) 
                else if (type.IsInterface) ExternalNestsdTypeDeclaration.[NestedInterfaceSymbol](name, type).DefineSymbol(declaredIn.MemberTable)
                else if (type.IsEnum)      ExternalNestsdTypeDeclaration.[NestedEnumSymbol]     (name, type).DefineSymbol(declaredIn.MemberTable)
                else if (type.IsValueType) ExternalNestsdTypeDeclaration.[NestedStructSymbol]   (name, type).DefineSymbol(declaredIn.MemberTable)
                else                       ExternalNestsdTypeDeclaration.[NestedClassSymbol]    (name, type).DefineSymbol(declaredIn.MemberTable);
            
            unless (symbol.IsDeclaredInEvaluated)
              symbol.DeclaredIn = declaredIn;

            initTypeSymbol(symbol, type);
            symbol
          }
          def loadNsMember(member : INamespaceMember, declaredIn : NamespaceSymbol) : void
          {
            match (member)
            {
              | type is INamespaceTypeDefinition when type.IsPublic =>
                def name = Name(noFile, noSpan, type.Name.Value); // TODO: type.Name.UniqueKey
                def symbol : TopTypeSymbol =
                         if (type.IsDelegate)  ExternalTopTypeDeclaration.[TopDelegateSymbol] (name, type).DefineSymbol(declaredIn.MemberTable) 
                    else if (type.IsInterface) ExternalTopTypeDeclaration.[TopInterfaceSymbol](name, type).DefineSymbol(declaredIn.MemberTable)
                    else if (type.IsEnum)      ExternalTopTypeDeclaration.[TopEnumSymbol]     (name, type).DefineSymbol(declaredIn.MemberTable)
                    else if (type.IsValueType) ExternalTopTypeDeclaration.[TopStructSymbol]   (name, type).DefineSymbol(declaredIn.MemberTable)
                    else                       ExternalTopTypeDeclaration.[TopClassSymbol]    (name, type).DefineSymbol(declaredIn.MemberTable);
                
                unless (symbol.IsDeclaredInEvaluated)
                  symbol.DeclaredIn = declaredIn;

                initTypeSymbol(symbol, type);
                      
              | cciNs is INamespaceDefinition => //loadNsMembers(ns, nsSymbol.MemberTable)
                def name   = NRB.Name(noFile, noSpan, cciNs.Name.Value); // TODO: ns.Name.UniqueKey
                def symbol = ExternalNamespaceDeclaration(name, cciNs).DefineSymbol(declaredIn.MemberTable);
                unless (symbol.IsDeclaredInEvaluated)
                  symbol.DeclaredIn = declaredIn;
                symbol.EvalProperties(context);
                foreach (subMember in cciNs.Members)
                  loadNsMember(subMember, symbol);
                
              | _ => {}
            }
          }
              
          foreach (subMember in unit.NamespaceRoot.Members)
            loadNsMember(subMember, rootNamespace);
            
        | _ => throw NotImplementedException("Loading types from " + lib + " not supported yet.")
      }

      Debug.WriteLine($"Read external symbols took: $(timer.Elapsed)");
            
      InitBaseTypeSet(context, cciInternedKeyToSymbolMap);
      
      Debug.WriteLine($"Total of LoadExternalSymbols took: $(timer.Elapsed)");

      rootNamespace
    }
    
    public Dispose() : void
    {
      when ((CciHost : object) is IDisposable as d)
        d.Dispose();
    }
    
    InitBaseTypeSet(context : DependentPropertyEvalContext, cciInternedKeyToSymbolMap : Hashtable[uint, TypeSymbol]) : void
    {
      def host   = CciHost;
      
      assert(true);
      def singleDimensionArray = SingleDimensionArraySymbol();
      singleDimensionArray.TypeParametersCount = 0;
      singleDimensionArray.EvalProperties(context);
      def cciObject = host.PlatformType.SystemObject.ResolvedType;
      mutable objectSymbol;
      unless (cciInternedKeyToSymbolMap.TryGetValue(cciObject.InternedKey, out objectSymbol))
        return;
      def timer = Stopwatch.StartNew();
      mutable resolvs = 0;
      mutable resolvedByKey = 0;
      mutable resolvedByResolvedTypeProp = 0;
      
      def makeSymbol(cciTypeReference : ITypeReference) : TypeSymbol
      {
        | t is IGenericTypeParameter =>
          def typeInfo = makeSymbol(t.DefiningType) :> GenericTypeSymbol;
          def tp = typeInfo.TypeParameters[t.Index];
          tp
          
        | t is IArrayTypeReference =>
          def args = array[makeSymbol(t.ElementType)];
          def typeInfo = if (t.IsVector) singleDimensionArray : ArraySymbol
                          else 
                          {
                            def a = MultiDimensionArraySymbol();
                            a.TypeParametersCount = 0;
                            a.Rank        = t.Rank;
                            //a.LowerBounds = t.LowerBounds.ToArray();
                            //a.Sizes       = t.Sizes.ToArray();
                            a.EvalProperties(context);
                            a
                          };
          def constructedType = TopConstructedTypeSymbol();
          constructedType.TypeInfo = typeInfo;
          constructedType.Args = args;
          constructedType.EvalProperties(context);
          constructedType
        
        | t is ITypeDefinition =>
          def cciInternedKeyToSymbolMap = cciInternedKeyToSymbolMap;
          mutable typeSymbol;
          if (cciInternedKeyToSymbolMap.TryGetValue(t.InternedKey, out typeSymbol))
          {
            typeSymbol
          }
          else
          {
            // the type definition not found
            objectSymbol
          }
          
        | t is IGenericTypeInstanceReference =>
          def typeInfo = makeSymbol(t.GenericType) :> GenericTypeSymbol;
          def args = t.GenericArguments.Select(makeSymbol).ToArray();

          def constructedType = TopConstructedTypeSymbol();
          constructedType.TypeInfo = typeInfo;
          constructedType.Args = args;
          constructedType.EvalProperties(context);
          constructedType
               
        | _ =>
          resolvs++;
          def cciInternedKeyToSymbolMap = cciInternedKeyToSymbolMap;
          mutable typeSymbol;
          
          if (cciInternedKeyToSymbolMap.TryGetValue(cciTypeReference.InternedKey, out typeSymbol))
          {
            resolvedByKey++;
            typeSymbol
          }
          else
          {
            objectSymbol
          }
      }
            
      foreach (x in cciInternedKeyToSymbolMap.Values)
      {
        def cciType = (x.FirstDeclarationOrDefault :> IExternalTypeDeclaration).Type;
        when (x is SupportsInheritanceTypeSymbol as type)
        {
          def baseTypeSet = BaseTypeReferenceSet(context);
          type.BaseTypeSet = baseTypeSet;
          foreach (cciBaseClasse in cciType.BaseClasses)
          {
            def typeSymbol = makeSymbol(cciBaseClasse);
            baseTypeSet.AddParent(typeSymbol);
          }
          foreach (cciInterface in cciType.Interfaces)
          {
            def typeSymbol = makeSymbol(cciInterface);
            baseTypeSet.AddParent(typeSymbol);
          }
        }
      }

      Debug.WriteLine($"InitBaseTypeSet took: $(timer.Elapsed) resolvs=$resolvs, resolvedByKey=$resolvedByKey, resolvedByResolvedTypeProp=$resolvedByResolvedTypeProp");
      assert(true);
    }
  }
  

  [Record]
  public class ExternalNamespaceDeclaration : ExternalDeclaration[NamespaceSymbol]
  {
    public Namespace : INamespaceDefinition { get; private set; }
    public override CreateSymbol() : DeclarationSymbol { NamespaceSymbol() }
  }
  
  public interface IExternalTypeDeclaration
  {
    Type : ITypeDefinition { get; }
  }

  public interface IExternalTopTypeDeclaration
  {
    Type : INamespaceTypeDefinition { get; }
  }

  public interface IExternalNestsdTypeDeclaration
  {
    Type : INestedTypeDefinition { get; }
  }

  [Record]
  public class ExternalTopTypeDeclaration[TSymbol] : ExternalDeclaration[TSymbol], IExternalTopTypeDeclaration, IExternalTypeDeclaration
    where TSymbol : DeclarationSymbol
  {
    public Type : INamespaceTypeDefinition { get; private set; }
  }

  [Record]
  public class ExternalNestsdTypeDeclaration[TSymbol] : ExternalDeclaration[TSymbol], IExternalNestsdTypeDeclaration, IExternalTypeDeclaration
    where TSymbol : DeclarationSymbol
  {
    public Type : INestedTypeDefinition { get; private set; }
  }

  [Record]
  public class TypeParameterDeclaration : ExternalDeclaration[TypeParameterSymbol]
  {
    public TypeParam : IGenericTypeParameter;
    public override CreateSymbol() : DeclarationSymbol { TypeParameterSymbol() }
  }
}
