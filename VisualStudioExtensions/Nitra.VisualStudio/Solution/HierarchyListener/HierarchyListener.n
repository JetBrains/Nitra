/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.TextManager.Interop;

using Nemerle.Assertions;
using Nemerle.Imperative;

using Nitra.VisualStudio.ErrorHelper;

using VSConstants = Microsoft.VisualStudio.VSConstants;

namespace Nitra.VisualStudio.Solution
{
  internal class HierarchyListener : IVsHierarchyEvents, IDisposable
  {
    private mutable hierarchy : IVsHierarchy;
    private mutable cookie    : uint;
    private _globalConfig     : INitraGlobalConfig;

    public this([NotNull] hierarchy : IVsHierarchy, globalConfig : INitraGlobalConfig)
    {
      this.hierarchy     = hierarchy;
      this._globalConfig = globalConfig;
    }

    #region Public Methods

    public Hierarchy : IVsHierarchy { get { hierarchy } }

    [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    public IsListening : bool { get { 0 != cookie } }

    public StartListening(doInitialScan : bool) : void
    {
      when (0 != cookie)
        return;

      _ = ThrowOnFailure(hierarchy.AdviseHierarchyEvents(this, out cookie));

      when (doInitialScan)
        InternalScanHierarchy(VSConstants.VSITEMID_ROOT);
    }

    [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    public StopListening() : void
    {
      _ = InternalStopListening(true);
    }

    #endregion

    #region IDisposable Members

    public Dispose() : void
    {
      _ = InternalStopListening(false);
      cookie = 0;
      hierarchy = null;
    }

    #endregion

    #region Public Events

    public event OnAddItem : EventHandler[HierarchyEventArgs];

    public event OnDeleteItem : EventHandler[HierarchyEventArgs];

    #endregion

    #region IVsHierarchyEvents Members

    public OnInvalidateIcon(_hicon : IntPtr) : int
    {
        // Do Nothing.
        VSConstants.S_OK
    }

    public OnInvalidateItems(_itemidParent : uint) : int
    {
      // TODO: Find out if this event is needed.
      Debug.WriteLine("\n\tOnInvalidateItems\n");
      VSConstants.S_OK
    }

    public OnItemAdded(_itemidParent : uint, _itemidSiblingPrev : uint, itemidAdded : uint) : int
    {
      // Check if the item is a python file.
      Debug.WriteLine("\n\tOnItemAdded\n");
      mutable name;

      when (IsNitraFile(itemidAdded, out name))
        OnAddItem?.Invoke(hierarchy, HierarchyEventArgs(itemidAdded, name));

      VSConstants.S_OK
    }

    public OnItemDeleted(itemid : uint) : int
    {
      Debug.WriteLine("\n\tOnItemDeleted\n");
      // Notify that the item is deleted only if it is a python file.
      mutable name;

      when (IsNitraFile(itemid, out name))
        OnDeleteItem?.Invoke(hierarchy, HierarchyEventArgs(itemid, name));

      VSConstants.S_OK
    }

    public OnItemsAppended(_itemidParent : uint) : int
    {
      // TODO: Find out what this event is about.
      Debug.WriteLine("\n\tOnItemsAppended\n");
        VSConstants.S_OK
    }

    public OnPropertyChanged(_itemid : uint, _propid : int, _flags : uint) : int
    {
      // Do Nothing.
      VSConstants.S_OK
    }

    #endregion

    private InternalStopListening(throwOnError : bool) : bool
    {
      when (hierarchy == null || 0 == cookie)
        return false;

      def hr = hierarchy.UnadviseHierarchyEvents(cookie);
      when (throwOnError)
        _ = ThrowOnFailure(hr);

      cookie = 0;
      Succeeded(hr)
    }

    private IsNitraFile(itemId : uint, canonicalName : out string) : bool
    {
      // Find out if this item is a physical file.
      mutable typeGuid = Guid.Empty;
      canonicalName = null;
      mutable hr =
        try hierarchy.GetGuidProperty(itemId, __VSHPROPID.VSHPROPID_TypeGuid :> int, out typeGuid);
        catch
        { | _ is System.Runtime.InteropServices.COMException => VSConstants.S_OK
            //For WPF Projects, they will throw an exception when trying to access this property if the
            //guid is empty. These are caught and ignored here.
        };

      when (Microsoft.VisualStudio.ErrorHandler.Failed(hr) || VSConstants.GUID_ItemType_PhysicalFile != typeGuid)
        // It is not a file, we can exit now.
        return false;

      // This item is a file; find if it is a pyhon file.
      hr = hierarchy.GetCanonicalName(itemId, out canonicalName);
      when (Microsoft.VisualStudio.ErrorHandler.Failed(hr))
        return false;

      if (_globalConfig != null)
      {
        def extension = System.IO.Path.GetExtension(canonicalName);
        def langOpt   = _globalConfig.GetLanguageByExtension(extension);
        langOpt.HasValue
      }
      else
        false
    }

    /// <summary>
    /// Do a recursive walk on the hierarchy to find all the python files in it.
    /// It will generate an event for every file found.
    /// </summary>
    private InternalScanHierarchy(itemId : uint) : void
    {
      mutable currentItem = itemId;
      while (VSConstants.VSITEMID_NIL != currentItem)
      {
        // If this item is a python file, then send the add item event.
        mutable itemName;
        when (IsNitraFile(currentItem, out itemName))
          OnAddItem?.Invoke(hierarchy, HierarchyEventArgs(currentItem, itemName));

        // NOTE: At the moment we skip the nested hierarchies, so here  we look for the
        // children of this node.
        // Before looking at the children we have to make sure that the enumeration has not
        // side effects to avoid unexpected behavior.
        mutable propertyValue;
        mutable canScanSubitems = true;
        mutable hr = hierarchy.GetProperty(currentItem, __VSHPROPID.VSHPROPID_HasEnumerationSideEffects :> int, out propertyValue);
        when ((VSConstants.S_OK == hr) && (propertyValue is bool))
          canScanSubitems = !(propertyValue :> bool);

        // If it is allow to look at the sub-items of the current one, lets do it.
        when (canScanSubitems)
        {
          mutable child;
          hr = hierarchy.GetProperty(currentItem, __VSHPROPID.VSHPROPID_FirstChild :> int, out child);
          when (VSConstants.S_OK == hr)
          {
              // There is a sub-item, call this same function on it.
            InternalScanHierarchy(GetItemId(child));
          }
        }

        // Move the current item to its first visible sibling.
        mutable sibling;
        hr = hierarchy.GetProperty(currentItem, __VSHPROPID.VSHPROPID_NextSibling :> int, out sibling);
        if (VSConstants.S_OK != hr)
          currentItem = VSConstants.VSITEMID_NIL;
        else
          currentItem = GetItemId(sibling);
      }
    }

    /// <summary>
    /// Gets the item id.
    /// </summary>
    /// <param name="variantValue">VARIANT holding an itemid.</param>
    /// <returns>Item Id of the concerned node</returns>
    private static GetItemId(variantValue : object) : uint
    {
      unchecked
        match (variantValue)
        {
          | null            => VSConstants.VSITEMID_NIL
          | uint   as value => value
          | int    as value => value :> uint
          | short  as value => value :> uint
          | ushort as value => value :> uint
          | long   as value => value :> uint
          | _               => VSConstants.VSITEMID_NIL
        }
    }
  }
}
